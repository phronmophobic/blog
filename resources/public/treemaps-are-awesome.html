<html lang="en"><head><meta charset="utf-8" /><meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport" /><meta content="Adrian Smith" name="author" /><link href="treemaps-are-awesome/favicon.ico" rel="icon" /><title>Treemaps are awesome!</title><link href="treemaps-are-awesome/bootstrap.min.css" rel="stylesheet" /><link href="treemaps-are-awesome/blog.css" rel="stylesheet" /><style type="text/css">.syntax pre {
  background: ;
}

.syntax pre .definition {
  color: #00f;
}

.syntax pre .core-fn {
  color: #30a;
}

.syntax pre .variable {
  color: black;
}

.syntax pre .number {
  color: #164;
}

.syntax pre .s-exp {
  color: #997;
}

.syntax pre .special-form {
  color: #30a;
}

.syntax pre .string {
  color: #a11;
}

.syntax pre .keyword {
  color: #708;
}

.syntax pre .macro {
  color: #05a;
}

.syntax pre .reader-char {
  color: #555;
}

.syntax pre .nil {
  color: #164;
}

.syntax pre .comment {
  color: #a50;
}

.syntax pre .repeat {
  color: #f00;
}

.syntax pre .regex {
  color: #f50;
}

.syntax pre .exception {
  color: #f00;
}

.syntax pre .boolean {
  color: #164;
}

.syntax pre .character {
  color: #f50;
}

.syntax pre .conditional {
  color: #30a;
} div.syntax { padding: 4px ; background-color: #f8f8f8; margin-bottom: 18px } div.syntax pre { margin-bottom: 0 }</style></head><body><div class="blog-masthead"><div class="container"><nav class="nav blog-nav"><a class="nav-link" href="/">Home</a><a class="nav-link active" href="#">Treemaps are awesome!</a><a class="nav-link" href="treemap-demo.html">Treemap Demo</a><a class="nav-link" href="https://github.com/phronmophobic/treemap-clj">Code on Github</a></nav></div></div><div class="blog-header"><div class="container"><h1 class="blog-title">Treemaps are awesome!</h1><p class="lead blog-description">An alternative to pprint for generically visualizing heterogeneous, hierarchical data</p></div></div><div class="container"><div class="row"><div class="col-sm-8 blog-main"><div class="blog-post"><div><h1 id="Why-treemaps">Why treemaps?</h1><p>Treemaps are an underutilized visualization that are capable of generically summarizing data of many shapes and sizes. To date, they&apos;ve mostly been used for displaying the files consuming all of your disk space, but with a few tweaks, treemaps can be a flexible tool for exploring and navigating messy data blobs.</p><p>Treemaps are space filling. You provide the bounds, and the the treemap algorithm will generate a graphic that uses all of the pixels. This is in contrast to something like pprint, which generates a view of the data that is proportional to the amount of data. Bounding the size of the visual representation has the advantage that treemaps scale gracefully for small to medium sized data.</p><p>Treemaps will use as many pixels as are available to represent the underlying data. In general, more pixels means more clarity. However, the treemap performs well even at relatively small sizes.</p><p><img alt="Sizes Example" src="treemaps-are-awesome/images/sizes-example.gif" style="max-width: 90vw;height:auto" /></p><p>Treemaps are very flexible. They can visualize any data that is tree-like which includes any data that can be represented as JSON or edn.</p><h1 id="What-are-treemaps">What are treemaps?</h1><blockquote class="blockquote"><p>treemapping is a method for displaying hierarchical data using nested figures, usually rectangles.<br /><footer class="blockquote-footer"><a href="https://en.wikipedia.org/wiki/Treemapping">wikipedia</a></footer></p></blockquote><p>At its heart, constructing a treemap is straightforward. Given some tree-like data and a rectangle, subdivide the rectangle into smaller rectangles for each of the tree&apos;s branches and then recursively apply the same algorithm for each branch.</p><div class="syntax"><pre><span class="s-exp">(</span><span class="definition">defn</span> <span class="symbol">treemap</span> <span class="s-exp">[</span><span class="symbol">tree-node</span> <span class="symbol">rect</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="special-form">if</span> <span class="s-exp">(</span><span class="symbol">branch?</span> <span class="symbol">tree-node</span><span class="s-exp">)</span>
    <span class="s-exp">(</span><span class="special-form">let</span> <span class="s-exp">[</span><span class="symbol">child-rects</span> <span class="s-exp">(</span><span class="symbol">subdivide</span> <span class="symbol">rect</span> <span class="s-exp">(</span><span class="symbol">children</span> <span class="symbol">tree-node</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">]</span>
      <span class="s-exp">(</span><span class="core-fn">mapcat</span> <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">child</span> <span class="symbol">child-rect</span><span class="s-exp">]</span>
                <span class="s-exp">(</span><span class="symbol">treemap</span> <span class="symbol">child</span> <span class="symbol">child-rect</span><span class="s-exp">)</span><span class="s-exp">)</span>
              <span class="s-exp">(</span><span class="symbol">children</span> <span class="symbol">tree-node</span><span class="s-exp">)</span>
              <span class="symbol">child-rects</span><span class="s-exp">)</span><span class="s-exp">)</span>
    <span class="s-exp">[</span><span class="symbol">rect</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>The size of each rectangle is proportional to the size of the associated tree node and all of its children. The more descendants a tree node has, the bigger its rectangle. As an additional feature, the function that determines the size of leaves and branches can be parameterized, but for our examples, we will assume all leaves have a size of 1 and the size of a branch is the sum of the leaves under it.</p><p>Here&apos;s what the process of subdivision looks like.</p><p><img alt="basic subdivide" src="treemaps-are-awesome/images/basic-subdivide.gif" style="max-width: 90vw;height:auto" /></p><p>You can see that the naive treemap shows some of the structure of the data we&apos;re trying to visualize, but many elements of the data&apos;s structure aren&apos;t revealed in this basic treemap. Next, we&apos;ll look at a few tricks for improving our treemaps to capture more elements of our data&apos;s structure. The following is by no means an exhaustive list of techniques. In fact, there&apos;s tremendous room for experimentation and improvement.</p><h2 id="Improving-the-traditional-treemap">Improving the traditional treemap</h2><p>Treemaps are really good at using all the available pixels, but there&apos;s still a lot of work left deciding how best to use the pixels given to us. There are several metrics and aspects that are possible to visualize. Let&apos;s consider a few.</p><p><strong>Types:</strong> What types are used in the data?<br /><strong>Shape:</strong> Is the data deep, shallow, thin, wide?<br /><strong>Cardinality:</strong> How much data is there?<br /><strong>Constraints:</strong> What properties must the data have for it to be considered valid?</p><h2 id="Types">Types</h2><p>One of the more obvious improvements is to paint the background of each rectangle with the type of the data it represents. Here&apos;s what that looks like:</p><p><img alt="Type Background" src="treemaps-are-awesome/images/type-background.png" style="max-width: 90vw;height:auto" /></p><p>Great, now we can see the types of our tree. However, there&apos;s a little snag in our plan. It turns out that for most JSON in the wild, the data is mostly comprised of just strings and numbers. It&apos;s really higher level data types that we would be interested in, but if we&apos;re interested in summarizing the data, it might be because don&apos;t have a schema handy. Automatically inferring data types is something we can work on, but let&apos;s move on to other options for now.</p><h2 id="Depth">Depth</h2><p>One of the issues with just showing types is that it doesn&apos;t tell us much about the actual structure of the data. Just from the types, we can&apos;t tell how deep or how wide the data is. If we&apos;re not using the background color to represent the types in the data, we can use it for depth:</p><p><img alt="Depth Background" src="treemaps-are-awesome/images/depth-background.png" style="max-width: 90vw;height:auto" /></p><p>Using the color for depth certainly illuminates whether or not our data structure is deep or wide, but it can still be difficult to decipher the structure of the example data. For example, &quot;Which rectangles share the same parent?&quot;</p><h3 id="Grouping">Grouping</h3><p>One way to visualize which rectangles share the same parent is to add a little padding around each level.</p><p><img alt="Depth Background" src="treemaps-are-awesome/images/depth-padding.png" style="max-width: 90vw;height:auto" /></p><p>Awesome. Just a little spacing helps track the different branches of the tree and see which elements share the same parents. However, there are some limitations with using only spacing to show grouping. How much padding should each level of the hierarchy have? Adding too little padding makes the hierarchies less apparent. Adding too much spacing can waste pixels that could otherwise be more effective. The shape of the data will also influence how much padding is necessary. Determining the amount of padding that works well on various different types of data is still an area that needs work.</p><h3 id="Hierarchy-Lines">Hierarchy Lines</h3><p>Another way to visualize the shape of data is to simply draw lines from parents to their children. We can even change the color of the line to show what type each collection is.</p><p><img alt="Line Depth" src="treemaps-are-awesome/images/line-bare-demo.png" style="max-width: 90vw;height:auto" /></p><p>The main drawback of hierarchy lines is that the lines can overlap and obscure descendant rectangles. We can partially alleviate the overlapping issue by reducing the hierarchy line&apos;s opacity near the top of the tree. However, for certain data shapes, the lines can still be an issue. Another way to declutter the graphic while still utilizing hierarchy lines is to allow the user to hover over the graphic and only show the hierarchy line of the element that is currently under the mouse.</p><p>Below is a visualization of the same data as above, but using the background to show depth and only showing the hierarchy lines when hovering.</p><p><img alt="Lines Interactive" src="treemaps-are-awesome/images/lines-interactive-shrunk.gif" style="max-width: 90vw;height:auto" /></p><h2 id="Labels">Labels</h2><p>For small examples it&apos;s possible to simply label all of the data.</p><pre><code>{:a [0 1 2 3 4],
 :b [0 1 2 3 4],
 :c [0 1 2 3 4]}
</code></pre><p><img alt="Simple Label Example" src="treemaps-are-awesome/images/simple-label-example.png" style="max-width: 90vw;height:auto" /></p><h2 id="Key-path-labels">Key path labels</h2><p>One common form of nesting is maps containing other maps. We can highlight important structural features of the data if we emphasize the map keys in our treemap.</p><p>Below is a treemap of all the public interns of namespaces on treemap-cljs&apos;s classpath that start with <code>clojure.*</code>.</p><p><img alt="Keyed Example" src="treemaps-are-awesome/images/keyed-example.png" style="max-width: 90vw;height:auto" /></p><p>As an additional help the user, we allow the user to hover over the data and show the key path that it would take to traverse the data to that leaf node.</p><p><img alt="Hover Keyed Example" src="treemaps-are-awesome/images/hover-keypath-shrunk.gif" style="max-width: 90vw;height:auto" /></p><p>Not only does showing the key path while hovering help show where the data is situated, we can use the key paths as part of the UI itself. As we hover over the keypath, watch as the area for that subsection of the tree is highlighted in the treemap graphic.</p><p><img alt="Hover Box Example" src="treemaps-are-awesome/images/keypath-box-hover-shrunk.gif" style="max-width: 90vw;height:auto" /></p><h1 id="Comparisons-with-alternatives">Comparisons with alternatives</h1><p>There are several tools that help us to gain an intuition for a particular data representation. Let&apos;s compare treemaps with other options to see how treemaps can most effectively be used as part of the data exploration toolset.</p><h3 id="Treemaps">Treemaps</h3><p>Treemaps excel at displaying high level structure that is heirarchical, heterogeneous, and approximately square (ie. the data is about as many layers deep as it is wide). Treemaps struggle with data that is either (wide and shallow) or (thin and deep).</p><h3 id="pprint">pprint</h3><p><code>pprint</code> excels at small to medium size data, especially if the data fits on a single page. Once the data takes more than a page to <code>pprint</code>, then it can obscure the shape and structure of the data.</p><h3 id="Data-Browsers">Data Browsers</h3><p>Data browsers like <a href="https://github.com/cognitect-labs/REBL-distro">rebl</a> excel at scanning through data, but typically only show one level of the data at a time. Many data browsers allow graphical integrations, so hopefully treemaps will be <a href="https://github.com/phronmophobic/treemap-clj">integrated</a> within data browsers to allow for the &quot;big picture&quot; data summarization that treemaps provide.</p><h3 id="Schemas">Schemas</h3><p>Schemas excel at providing an abstract summary of data. Schemas have trouble with deeply nested data, data that are out of sync with the schema, and data that don&apos;t have a schema. Additionally, schemas don&apos;t usually detail real world usage. They often contain properties that are no longer used or have developed new meaning compared to what the original property name would suggest. Schemas are still very useful and can complement tools that work with concrete instances of data like treemaps, <code>pprint</code>, and data browsers.</p><h1 id="Future-Work">Future Work</h1><p><strong>More sophisticated layout</strong><br />Treemap layout in <code>treemap-clj</code> is fairly naive. The layout only considers one level at a time and only uses simple to heuristics to prefer squarish rectangles (aspect ratios close to 1) over long and thin rectangles.</p><p>Currently, layout of the treemap rectangles is only done one layer at at time. It should be possible to produce better (for various metrics of better) layouts by considering more than one layer of the tree at a time.</p><p><strong>Non rectangular treemaps</strong><br />All <code>treemap-clj</code> layouts subdivide rectangles into smaller rectangles. However, the <a href="https://www.uni-konstanz.de/mmsp/pubsys/publishedFiles/NoBr12a.pdf">literature</a> contains algorithms that subdivide areas into other shapes which could have interesting applications.</p><p><strong>Interactive depth rendering</strong><br />Allowing a user to interactively render a treemap up to X level of depth is likely to be an interesting way of exploring a data structure.</p><p><strong>Alternative coloring schemes</strong><br />Only two uses of color have been presented as part of <code>treemap-clj</code>, depth and data type. Other coloring schemes should be investigated.</p><p><strong>Alternative size functions</strong><br />As noted above, all <code>treemap-clj</code> implementations use a leaf size of 1. Plugging in different sizing functions would allow the user to emphasize different elements of a data structure.</p><p><strong>Use Layout direction to encode more information</strong><br />If you look at other visualization graphics, the directions on the chart typically encode information (eg. a financial chart that goes up and to the right is usually a positive sign). The directions on a treemap don&apos;t encode any meaning. It should be possible to place rectangles with certain properties close to either the edges or towards the center to emphasize different qualities of the data.</p><p><strong>Graphic Design</strong><br />I&apos;m bad at graphic design and have probably violated innumerable graphic design principles. Incorporating graphic design expertise would greatly increase clarity and legibility.</p><p><strong>Constraints, schemas and specs</strong><br />Formal data specifications encode a ton of information. Encoding these specifications into the treemap graphic should increase the information density.</p><p><strong>Zooming in and out</strong><br />Just like with geographic maps, it should be possible to zoom in on a part of a treemap to reveal more detail or zoom out to view higher level data features.</p><h1 id="Further-Reading">Further Reading</h1><p>Visualizing business information using generalized treemaps<br /><a href="https://pure.tue.nl/ws/files/47041749/631721-1.pdf">https://pure.tue.nl/ws/files/47041749/631721-1.pdf</a></p><p>Visualizing Business Data with Generalized Treemaps<br /><a href="https://ieeexplore.ieee.org/document/4015431">https://ieeexplore.ieee.org/document/4015431</a></p><p>Computing Voronoi Treemaps<br /><a href="https://www.uni-konstanz.de/mmsp/pubsys/publishedFiles/NoBr12a.pdf">https://www.uni-konstanz.de/mmsp/pubsys/publishedFiles/NoBr12a.pdf</a></p><p>Fast Dynamic Voronoi Treemaps<br /><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/isvd.pdf">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/isvd.pdf</a></p></div></div></div></div></div></body></html>