<html lang="en"><head><meta charset="utf-8" /><meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport" /><meta content="Adrian Smith" name="author" /><link href="html-tax/favicon.ico" rel="icon" /><title>The HTML Tax</title><link href="html-tax/bootstrap.min.css" rel="stylesheet" /><link href="html-tax/blog.css" rel="stylesheet" /><style type="text/css">.syntax pre {
  background: ;
}

.syntax pre .definition {
  color: #00f;
}

.syntax pre .core-fn {
  color: #30a;
}

.syntax pre .variable {
  color: black;
}

.syntax pre .number {
  color: #164;
}

.syntax pre .s-exp {
  color: #997;
}

.syntax pre .special-form {
  color: #30a;
}

.syntax pre .string {
  color: #a11;
}

.syntax pre .keyword {
  color: #708;
}

.syntax pre .macro {
  color: #05a;
}

.syntax pre .reader-char {
  color: #555;
}

.syntax pre .nil {
  color: #164;
}

.syntax pre .comment {
  color: #a50;
}

.syntax pre .repeat {
  color: #f00;
}

.syntax pre .regex {
  color: #f50;
}

.syntax pre .exception {
  color: #f00;
}

.syntax pre .boolean {
  color: #164;
}

.syntax pre .character {
  color: #f50;
}

.syntax pre .conditional {
  color: #30a;
} div.syntax { padding: 4px ; background-color: #f8f8f8; margin-bottom: 18px } div.syntax pre { margin-bottom: 0 }</style></head><body><div class="blog-masthead"><div class="container"><nav class="nav blog-nav"><a class="nav-link" href="/">Home</a></nav></div></div><div class="blog-header"><div class="container"><h1 class="blog-title">The HTML Tax</h1><p class="lead blog-description">Html is a poor medium for specifying user interfaces</p></div></div><div class="container"><div class="row"><div class="col-sm-8 blog-main"><div class="blog-post"><div><ul><li><a href="#Introduction">Introduction</a></li><li><a href="#The-Problem">The Problem</a></li><li><a href="#What-is-a-User-Interface">What is a User Interface?</a></li><li><a href="#What-is-HTML">What is HTML?</a></li><ul><li><a href="#Graphics">Graphics</a></li><ul><li><a href="#What-is-a-div">What is a div?</a></li><li><a href="#HTML-makes-poor-data">HTML makes poor data</a></li><li><a href="#HTML-is-lossy">HTML is lossy</a></li></ul><li><a href="#Events">Events</a></li><li><a href="#UI-State-Management">UI State Management</a></li></ul><li><a href="#The-Escape-Plan">The Escape Plan</a></li><li><a href="#The-Escape">The Escape</a></li><ul><li><a href="#Painting-with-Code">Painting with Code</a></li><li><a href="#The-Game-Industry">The Game Industry</a></li></ul><li><a href="#Benefits">Benefits</a></li><ul><li><a href="#Increased-productivity">Increased productivity</a></li><li><a href="#Better-tooling">Better tooling</a></li><li><a href="#Increased-performance">Increased performance</a></li><li><a href="#Accessibility">Accessibility</a></li><li><a href="#Easier-testing">Easier testing</a></li><li><a href="#Access-to-More-Platforms">Access to More Platforms</a></li></ul><li><a href="#Alternative-Formats">Alternative Formats</a></li><ul><li><a href="#What-makes-a-good-format">What makes a good format?</a></li></ul><li><a href="#Conclusion">Conclusion</a></li><li><a href="#Footnotes">Footnotes</a></li></ul><blockquote class="blockquote"><p>Prudence, indeed, will dictate that data formats long established should not be changed for light and transient causes. Accordingly all experience hath shown, that programmers are more disposed to suffer, while evils are sufferable, than to right themselves by abolishing the forms to which they are accustomed.<br /><footer class="blockquote-footer">Thomas Json</footer></p></blockquote><h1 id="Introduction">Introduction</h1><p>It&apos;s time we start moving away from specifying our user interfaces in HTML. This idea may seem crazy since the web is one of the best, if not <em>the</em> best platform for distributing software. Below is an overview of how HTML degrades the quality of our user interfaces and provides a not so crazy plan for ditching the venerable <code>&lt;div/&gt;</code>.</p><h1 id="The-Problem">The Problem</h1><p>Convincing folks to abandon HTML is difficult because specifying user interfaces in HTML makes most tasks harder, but it rarely makes anything impossible. The truth is that switching to another format besides HTML won&apos;t let you do anything you couldn&apos;t already do (given enough time and resources). Anything you could do in another format, you could technically do in HTML.</p><p>However, <strong>HTML is a tax on every workflow it touches.</strong> For reasons described below, using HTML is cumbersome and awkward. Fortunately, you can avoid the HTML tax by defining your user interfaces in a different format. Evading the HTML tax doesn&apos;t directly let you do anything you couldn&apos;t be doing anyways, but it enables many enhancements to your workflow that wouldn&apos;t be worth the investment otherwise. We&apos;ll get to all the exciting opportunities that await us in the tax free zone, but first let&apos;s start from the beginning and explain why HTML is unsuitable.</p><h1 id="What-is-a-User-Interface">What is a User Interface?</h1><p>Every once in a while, it&apos;s worth it to take a step back to think about what we&apos;re actually trying to accomplish. We should periodically pause and ask ourselves big picture questions to make sure we&apos;re on the right track.</p><ul><li><p>What is a user interface?</p></li><li><p>What are the basic building blocks of user interfaces?</p></li><li><p>What should the basic building blocks be?</p></li><li><p>What methods, processes, and tools do we need to build complex complicated user interfaces without making an unintelligible mess?</p></li></ul><p>Answering &quot;What is a user interface?&quot; could be a post all on its own, but for now, we&apos;ll start with this brief (and oversimplified) definition.</p><p>The primary duties of a user interface are:</p><ol><li><p>Presenting the state of a program</p></li><li><p>Interpreting user input</p></li></ol><p>For this post, we&apos;ll further simplify our definition to focus on</p><ol><li><p><strong>Graphics</strong>: visually displaying the state of a program</p></li><li><p><strong>Events</strong>: user input from the mouse and keyboard.</p></li><li><p><strong>UI State Management</strong>: state unrelated to our application model necessary for handling graphics and events (eg. keeping track of which element has focus).</p></li></ol><h1 id="What-is-HTML">What is HTML?</h1><p>At 1,297 pages, the <a href="https://html.spec.whatwg.org/print.pdf">HTML Living Standard</a> is expansive. In the next sections, we&apos;re going to beat up a bit on HTML and it&apos;s important to clarify which parts of HTML are problematic. HTML isn&apos;t all bad and parts of it are straightforward, pragmatic, and endearing. To really tease apart the good from the bad, we&apos;ll have to retread some definitions we all already know.</p><blockquote class="blockquote"><p>Hypertext Markup Language (HTML) is the standard markup language for documents designed to be displayed in a web browser. It can be assisted by technologies such as Cascading Style Sheets (CSS) and scripting languages such as JavaScript.<br /><footer class="blockquote-footer"><a href="https://en.wikipedia.org/wiki/HTML">HTML - Wikipedia</a></footer></p></blockquote><p>Logically, HTML is a tree of HTML elements. Each element has a tag name and optional attributes. Depending on the tag type, an element may also have other HTML elements as children. HTML markup contains special elements like <code>&lt;div&gt;</code> and <code>&lt;span&gt;</code> that the browser interprets to display the HTML document and provide interactivity.</p><p><strong>For the rest of this post</strong>, when we refer to HTML, we&apos;re really referring to the special meaning given to the special elements. Further, we&apos;re really only focusing on the special elements that affect the graphics, event model, and state management of user interfaces targeting the web browser.</p><p>While we&apos;re clearing the air, I&apos;d like to emphasize that there is absolutely nothing wrong with defining a user interface in terms of a tree of tagged elements and attributes. The issues brought up in this post focus solely on the semantics associated with the special elements imparted by the browser. Practically speaking, that means that if you&apos;re using a ui framework that doesn&apos;t care whether you&apos;re using <code>&lt;div&gt;</code>s, <code>&lt;View&gt;</code>s, or any other specific tag type, then your framework is in harmony with the views of this post. Fortunately, most popular frameworks like React, re-frame, Angular, or any framework that allows user defined components are philosophically compatible.</p><h2 id="Graphics">Graphics</h2><h3 id="What-is-a-div">What is a div?</h3><p>The easiest way to show that HTML is a bad fit for specifying user interfaces is that UI designers don&apos;t work or design in terms of HTML. Even when an interface is being designed specifically for the web, it&apos;s rare for designers to use HTML elements as building blocks. Typically, the building blocks consist of text, shapes, groups, and images. In addition to HTML not being a natural representation, HTML has poor, ad hoc support for shapes. It&apos;s not impossible to embed shapes, but it&apos;s awkward enough that it&apos;s not very common.</p><p>Since designers don&apos;t work in terms of HTML elements, a considerable amount of effort is spent reimplementing UI designs in HTML. Since HTML maps poorly to UI designs, small changes in design can often mean disproportionately large changes in the HTML representation. Small design tweaks can take a considerable amount of work to reimplement. This is a huge waste of time.</p><p>Flexbox and other improvements have eased the process of reimplementing UI designs into HTML/CSS, but HTML still remains an unnatural fit for specifying UI designs. Most graphic design tools don&apos;t even bother to export HTML because HTML&apos;s inadequacies mean that it&apos;s difficult to figure out what an &quot;Export to HTML&quot; option should produce.</p><h3 id="HTML-makes-poor-data">HTML makes poor data</h3><p>It&apos;s unclear what a snippet of HTML conveys. To get any definitive meaning out of HTML requires firing up a full web browser, opening the web page, and &quot;seeing what happens&quot;. Given a snippet of HTML, it can be difficult to reliably guess what pixels will pop out the other side.</p><p>This is further complicated by the fact that rendering a web page isn&apos;t just about HTML, it&apos;s also about the CSS and JavaScript engines <strong>directly</strong> attached to the HTML renderer. Even simply producing a png image from HTML requires a full HTML and CSS engine. If you wanted to accomplish something even slightly more complex, like measuring the sizes of sub-elements in some HTML, you&apos;re going to have to run it through the engine and then query the DOM by passing js to the attached JavaScript engine.</p><p title="table flip">(‚ïØ¬∞‚ñ°¬∞Ôºâ‚ïØÔ∏µ ‚îª‚îÅ‚îª</p><blockquote class="blockquote"><p>So what if you need a full browser engine to poke at some HTML? How else what you do it?</p></blockquote><p>Data should be semantically transparent. A data format should have meaning outside of any specific implementation. It shouldn&apos;t mean &quot;whatever shows up in Chrome today&quot;. There&apos;s a lot of times when we&apos;d like to generically debug, profile, manipulate, and inspect a UI component, but it&apos;s so cumbersome that that we don&apos;t do it.</p><p>It may seem like I&apos;m being a bit unfair and I wish that were true, but the elusive nature of HTML is baked into the living standard.</p><blockquote class="blockquote"><p>User agents are not required to present HTML documents in any particular way. However, this section provides a set of suggestions for rendering HTML documents that, if followed, are likely to lead to a user experience that closely resembles the experience intended by the documents&apos; authors.<br /><footer class="blockquote-footer"><a href="https://html.spec.whatwg.org/multipage/rendering.html#rendering">The HTML Living Standard</a></footer></p></blockquote><h3 id="HTML-is-lossy">HTML is lossy</h3><p>We haven&apos;t talked about what kind of data format we should be using yet, but whichever format we choose, we want it to be lossless. In other words, we should be able to convert our graphics representation to another similar format and back again without any loss of information. So many workflows struggle because their UIs are defined in HTML and HTML is awful for generic processing. Sure, it&apos;s easy to manipulate HTML and produce other valid HTML, but the semantic meaning of HTML is opaque. For example, with a sane graphical format you could automatically validate a UI component against a style guide that specifies colors, paddings, spacing, and minimum sizes for interactive elements. If your interface is encoded in HTML, it&apos;s very difficult.</p><p>We have all these fancy, functional frameworks that let you build interfaces out of pure functions mapping application data to HTML elements, but the whole enterprise is undermined by the fact that DOM elements are basically useless as data unless the DOM elements are directly handed to the browser. Building higher level tooling on top of HTML is really cumbersome. Once you end up with HTML, that&apos;s it. There&apos;s no going back. The only useful thing you can do is hand it to a browser. Common practice is to start with HTML which means we&apos;re really shooting ourselves in the <span title="everybody is each shooting just one foot in this metaphor">foots</span>.</p><h2 id="Events">Events</h2><p>Event handling in the browser is fairly reasonable. Any idiosyncrasies can be papered over by libraries. However, since the browser&apos;s event system is necessarily coupled to the graphical output of HTML, any tooling or testing that relies on events will require a full browser engine. If you want to know what happens when the user clicks the mouse at the coordinate <code>(x,y)</code>, then you need to know which elements contain <code>(x,y)</code> which requires rendering HTML. If you&apos;ve ever tried to set up automated UI testing like Selenium, then you have paid the HTML tax on event handling.</p><h2 id="UI-State-Management">UI State Management</h2><p>There are a plethora of state management libraries for web apps. These libraries help tame the necessary complexity of the state needed to build user interfaces. The HTML tax comes due whenever you use HTML elements that try to manage state for you. When the browser manages UI state for you, you lose the benefits of whichever state management library you chose. Techniques like React&apos;s <a href="https://reactjs.org/docs/forms.html#controlled-components">controlled components</a> are generally effective, but only works for certain kinds of state.</p><p>Notable exceptions include:</p><ul><li><p>scrolling</p></li><li><p>text cursor</p></li><li><p>text selection</p></li><li><p>focus</p></li><li><p>hover state</p></li><li><p><code>&lt;img/&gt;</code> src loading</p></li></ul><p>Hopefully, your interface is happy using the builtin behavior because if not, you&apos;ll need to resort to a gamut of hacky workarounds.<sup><a href="#footnote-1" name="footnote-ref-1" title="[Code Mirror example 1](https://github.com/codemirror/CodeMirror/blob/0b64369b54503150f054abda50359c76f00f484f/src/edit/mouse_events.js#L400)">1</a></sup> <sup><a href="#footnote-2" name="footnote-ref-2" title="[Code Mirror Example 2](https://github.com/codemirror/CodeMirror/blob/c41dec13675da74fb575006a502d7daee6abdafe/src/input/ContentEditableInput.js#L250)">2</a></sup> <sup><a href="#footnote-3" name="footnote-ref-3" title="[Code Mirror Example 3](https://github.com/codemirror/CodeMirror/blob/c41dec13675da74fb575006a502d7daee6abdafe/src/input/ContentEditableInput.js#L94)">3</a></sup> <sup><a href="#footnote-4" name="footnote-ref-4" title="[Code Mirror Example 4](https://github.com/codemirror/CodeMirror/blob/b5ce22f1e350431adaefbad40cbfc54dbfdb1c77/src/input/input.js#L122)">4</a></sup></p><h1 id="The-Escape-Plan">The Escape Plan</h1><p>The good news is that we already have a playbook for ditching HTML. It&apos;s not the first time we&apos;ve been required to use a technology that was a poor fit.</p><p>JavaScript üëÄ</p><p>The JavaScript that gets shipped to the browser isn&apos;t the same code we work with in development. In some cases, we&apos;re not even developing in JavaScript. We code using a more comfortable language or dialect and then transpile, minify, and repackage the source into JavaScript that produces the same behavior, but with better performance and a smaller payload. We&apos;ve increased productivity and performance by expanding our language options and we can do the same with HTML. We can work in a medium that matches our mental model and still leverage the ubiquity of the web for software distribution.</p><p>The goal isn&apos;t to abandon the web browser. It&apos;s to work with a more natural representation and use an automatic process to generate HTML that produces the same result. The crazy thing is that a common objection to generating HTML from another source is a dissatisfaction with the quality of the generated HTML. In other words, HTML has such an impedance mismatch with the way we conceptualize UI that it&apos;s difficult to programmatically generate HTML that matches our intention. This impedance mismatch is the reason we shouldn&apos;t be using HTML in the first place! Fortunately, the libraries, tooling, and techniques needed for transpiling have come a long way and building a quality transpiler is very doable.</p><h1 id="The-Escape">The Escape</h1><h2 id="Painting-with-Code">Painting with Code</h2><p>Not only is using an alternative UI source representation possible, it&apos;s already happening. In <a href="https://airbnb.design/painting-with-code/">Painting With Code</a>, Airbnb&apos;s design team builds a new design tool that increases their productivity. It&apos;s buried in the middle of the story, but if you read carefully, you&apos;ll see that by using an appropriate UI representation, they have unlocked massive potential.</p><blockquote class="blockquote"><p>A breakthrough came when Airbnb engineer Leland Richardson proposed using React Native-style components. <code>&lt;View&gt;</code>, <code>&lt;Text&gt;</code>, etc. are the basic units of composition for design systems, so that semantically linked our Sketch components with their production counterparts. More excitingly, with Leland‚Äôs React Primitives project we could render real React components to Sketch, the browser, and our phones at the same time.</p></blockquote><blockquote class="blockquote"><p>We began the project to reduce the time it takes to generate static assets. But through exploring its edges and adjacent possibilities, we‚Äôre unearthing exciting and novel ways of interacting with design systems in Sketch. Many tasks that were previously unfeasible, required massive human input, or relied on sketchy (sorry) plugins are now enabled with the same code that our engineers are writing day-to-day.</p></blockquote><p>For more, check out <a href="http://airbnb.io/react-sketchapp/docs/guides/universal-rendering.html">react-sketchapp</a> and <a href="https://github.com/lelandrichardson/react-primitives">react-primitives</a>.</p><h2 id="The-Game-Industry">The Game Industry</h2><p>If you want to see what life could be like when you don&apos;t have to pay the HTML tax, check out what&apos;s going on in the game industry. The game industry develops interfaces that are complicated, beautiful, fun, and efficient. The interfaces run natively on multiple platforms, and their designers have direct control over the look and feel of the final product. There&apos;s no reason we couldn&apos;t be doing the same for web interfaces.</p><h1 id="Benefits">Benefits</h1><blockquote class="blockquote"><p>&quot;Data dominates. If you&apos;ve chosen the right data structures and organized things well, the algorithms will almost always be self-evident. Data structures, not algorithms, are central to programming.&quot; <footer class="blockquote-footer">Rob Pike</footer></p></blockquote><h2 id="Increased-productivity">Increased productivity</h2><p>As an industry, we waste an enormous amount of time reimplementing user interfaces in HTML. Instead, we should be empowering our UI designers with direct control over the output of their work. Requiring UI designers to go through a programmer to fix a pixel is immoral.</p><h2 id="Better-tooling">Better tooling</h2><p>If you&apos;re using the right format, you can build better tools. Tools like <a href="http://airbnb.io/react-sketchapp/docs/guides/universal-rendering.html">react-sketchapp</a>, <a href="https://origami.design/">origami</a>, <a href="https://developer.apple.com/xcode/interface-builder/">Interface Builder</a>, <a href="https://www.mapeditor.org/">Tiled</a>, and others can help increase productivity and they&apos;re only worth it for non HTML source formats.</p><p>Chrome devtools is really great, but again, it&apos;s directly attached to the web browser. It&apos;s so cumbersome to do anything with HTML outside the web browser that more and more tools are getting forced into the web browser itself. We should be using the best tool for the job and not be forcing ourselves into a corner based off the platforms we&apos;re targeting.</p><h2 id="Increased-performance">Increased performance</h2><p>When we minify and/or compile our code into JavaScript, we produce JavaScript that has the same semantics as our original code, but with a reduced payload and faster runtime. It&apos;s a win for the developer and the user. There&apos;s no reason we can&apos;t do the same for HTML.</p><h2 id="Accessibility">Accessibility</h2><p>When we stop hand coding every <code>&lt;div&gt;</code> and <code>&lt;span&gt;</code>, it makes it easier, not harder, to improve the accessibility of the resulting HTML. Working at a higher level allows us to implement better verification of accessibility. The biggest win of working at a higher level is the ability to generate multiple builds. It would then be possible to have a build target specifically optimized for accessibility.</p><h2 id="Easier-testing">Easier testing</h2><p>Setting up Selenium or other another browser automation tool to test our code is a huge pain. We should be able to test our UI code as simply as we test all of our other code.</p><h2 id="Access-to-More-Platforms">Access to More Platforms</h2><p>HTML really only works in the browser. If you use more natural primitives, you can target more platforms like iOS, android, webgl, desktop, and more. I&apos;m not advocating that we forgo the unique capabilities of each platform, but we shouldn&apos;t unnecessarily limit ourselves to only being able to run within a browser.</p><h1 id="Alternative-Formats">Alternative Formats</h1><p>If you want to get started today, some options to consider are <a href="https://github.com/lelandrichardson/react-primitives">react-primitives</a> and svg. These options aren&apos;t perfect, but they&apos;re all better than HTML in the ways we talked about.</p><p>Ideally, we would like an <strong>intermediate representation</strong> analogous to <a href="https://llvm.org/docs/LangRef.html">llvm IR (Intermediate Representation)</a> targeted at representing user interfaces. The purpose of the intermediate representation would be to have a common format between source representations from design programs (like sketch, figma, and illustrator) and platform formats (like web/HTML, iOS/UIView, android/View, etc.). The llvm IR is targeted at representing programs and is not a suitable for representing user interfaces, but its utility as part of the compilation pipeline can provide inspiration for what an intermediate representation for specifying user interfaces might look like.</p><h2 id="What-makes-a-good-format">What makes a good format?</h2><p>If we&apos;re not going to use HTML, our options are:</p><ol><li><p>Choosing an existing format while possibly adding some improvements</p></li><li><p>Creating a new format</p></li><li><p>&quot;Fixing&quot; HTML<sup><a href="#footnote-5" name="footnote-ref-5" title="It seems difficult, but it&apos;s entirely possible that there may be a way to define a subset of HTML/CSS that runs as is within the browser, but also addresses the issues raised above">5</a></sup></p></li></ol><p>If we&apos;re considering multiple options, we should start with some criteria to help evaluate which option is the best fit. In 1996, the W3C published a <a href="https://www.w3.org/Graphics/ScalableReq.html">list of requirements</a> when assessing proposals for a vector graphics format. Despite its age, it&apos;s actually a pretty good starting point.</p><blockquote class="blockquote"><p><strong>Open specification</strong></p><ul><li><p>Open specification - not subject to sudden change by a single vendor. Preferably submitted to an open forum such as W3C, IETF RFC, etc.</p></li><li><p>Ready availability to the casual implementer is desirable.</p></li><li><p>Extensible to cope with changing requirements</p></li><li><p>Widely implemented; at minimum, proof of concept implementation.</p></li><li><p>Reference code desirable</p></li><li><p>Lack of subset problems, incompatible generator/reader sets.</p></li></ul><p><strong>Graphical facilities</strong></p><ul><li><p>Vector graphics - line segments, closed filled shapes</p></li><li><p>Curved elements</p></li><li><p>Text, ISO10646 repertoire, font selection</p></li><li><p>Truecolor mode - not restricted to indexed color</p></li><li><p>Transparency (alpha)</p></li><li><p>Layering, stencilling/masking</p></li><li><p>Control of line termination and mitring</p></li><li><p>Levels of detail</p></li><li><p>Include raster data</p></li></ul></blockquote><p>The requirements also specify some requirements for interaction. However, we have to be really careful about glomming an interaction/event model onto a graphics format. User interfaces do require an event model, but graphics don&apos;t. We should be able to extract just the graphics or just the interactive part of our user interface.</p><p>Additionally, whichever format we choose will be acting as an intermediate representation(IR) between design formats and platform formats. As an intermediate representation, we should also be evaluating the following qualities:</p><ul><li><p>An IR is designed to be conducive for further processing, such as optimization and translation.</p></li><li><p>A &quot;good&quot; IR must be accurate ‚Äì capable of representing the user interfaces without loss of information</p></li><li><p>Independent of any particular source or target language.</p></li></ul><p>Choosing a representation that makes a good IR also has the benefit that it reduces our risk of choosing the wrong format. Since an intermediate representation is already suited for translation, it means we can easily switch to a better format should the need arise.</p><p>Since our IR will be used for tooling, we would like to be able to generically manipulate and inspect the format. Transformations and inspection should be achievable without a web browser. Examples of inspection and transformation</p><ul><li><p>Generically walk elements and sub-elements</p></li><li><p>Produce images from the format</p></li><li><p>Query layout information of elements and sub-elements</p></li><li><p>Determine which event handlers would be triggered by which events</p></li></ul><h1 id="Conclusion">Conclusion</h1><blockquote class="blockquote"><p>I am going to pull a date of the air right now. April 13th, 2002. That is the last day you evaluated your [ui data format] needs. Is it not?<br /><footer class="blockquote-footer">Michael Scott</footer></p></blockquote><p>HTML is the default option for writing web apps. We pick HTML not because we&apos;ve determined that it&apos;s the best option, but because it&apos;s the easiest way to get started. Picking a ui data format has a huge influence on our development workflows and the quality of our products.</p><ul><li><p>How much time spent building user interfaces with HTML is spent on incidental complexity?</p></li><li><p>Does working in HTML help us focus on domain problems?</p></li><li><p>Is HTML great for tooling?</p></li><li><p>Do hand picked HTML tags produce the best performance?</p></li><li><p>Is HTML easy to maintain and update?</p></li><li><p>Are interfaces built in HTML easy to test?</p></li></ul><p>As a data format, HTML isn&apos;t going anywhere, but that doesn&apos;t mean we should be hand picking every <code>&lt;div/&gt;</code> and <code>&lt;span/&gt;</code>. As we continue to build bigger and better browser apps, we should evaluate whether HTML really is the best source format for user interfaces and whether that will continue to be true in the future.</p><h1 id="Footnotes">Footnotes</h1><div class="footnotes"><div><a href="#footnote-ref-1" name="footnote-1">1</a>. <a href="https://github.com/codemirror/CodeMirror/blob/0b64369b54503150f054abda50359c76f00f484f/src/edit/mouse_events.js#L400">Code Mirror example 1</a></div><div><a href="#footnote-ref-2" name="footnote-2">2</a>. <a href="https://github.com/codemirror/CodeMirror/blob/c41dec13675da74fb575006a502d7daee6abdafe/src/input/ContentEditableInput.js#L250">Code Mirror Example 2</a></div><div><a href="#footnote-ref-3" name="footnote-3">3</a>. <a href="https://github.com/codemirror/CodeMirror/blob/c41dec13675da74fb575006a502d7daee6abdafe/src/input/ContentEditableInput.js#L94">Code Mirror Example 3</a></div><div><a href="#footnote-ref-4" name="footnote-4">4</a>. <a href="https://github.com/codemirror/CodeMirror/blob/b5ce22f1e350431adaefbad40cbfc54dbfdb1c77/src/input/input.js#L122">Code Mirror Example 4</a></div><div><a href="#footnote-ref-5" name="footnote-5">5</a>. It seems difficult, but it&apos;s entirely possible that there may be a way to define a subset of HTML/CSS that runs as is within the browser, but also addresses the issues raised above</div></div></div></div></div></div></div></body></html>