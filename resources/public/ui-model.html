<html lang="en"><head><meta charset="utf-8" /><meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport" /><meta content="Adrian Smith" name="author" /><link href="ui-model/favicon.ico" rel="icon" /><title>Implementing a Functional UI Model</title><link href="ui-model/bootstrap.min.css" rel="stylesheet" /><link href="ui-model/blog.css" rel="stylesheet" /><style type="text/css">.syntax pre {
  background: ;
}

.syntax pre .definition {
  color: #00f;
}

.syntax pre .core-fn {
  color: #30a;
}

.syntax pre .variable {
  color: black;
}

.syntax pre .number {
  color: #164;
}

.syntax pre .s-exp {
  color: #997;
}

.syntax pre .special-form {
  color: #30a;
}

.syntax pre .string {
  color: #a11;
}

.syntax pre .keyword {
  color: #708;
}

.syntax pre .macro {
  color: #05a;
}

.syntax pre .reader-char {
  color: #555;
}

.syntax pre .nil {
  color: #164;
}

.syntax pre .comment {
  color: #a50;
}

.syntax pre .repeat {
  color: #f00;
}

.syntax pre .regex {
  color: #f50;
}

.syntax pre .exception {
  color: #f00;
}

.syntax pre .boolean {
  color: #164;
}

.syntax pre .character {
  color: #f50;
}

.syntax pre .conditional {
  color: #30a;
} div.syntax { padding: 4px ; background-color: #f8f8f8; margin-bottom: 18px } div.syntax pre { margin-bottom: 0 }</style></head><body><div class="blog-masthead"><div class="container"><nav class="nav blog-nav"><a class="nav-link" href="/">Home</a></nav></div></div><div class="blog-header"><div class="container"><h1 class="blog-title">Implementing a Functional UI Model</h1><p class="lead blog-description">How to build a functional UI library from scratch: Part II</p></div></div><div class="container"><div class="row"><div class="col-sm-8 blog-main"><div class="blog-post"><div><ul><li><a href="#Introduction">Introduction</a></li><li><a href="#Event-loops">Event loops</a></li><li><a href="#Graphics">Graphics</a></li><ul><li><a href="#View-Function">View Function</a></li><li><a href="#Grouping">Grouping</a></li><li><a href="#Transforms">Transforms</a></li><li><a href="#Convenience-Wrappers">Convenience Wrappers</a></li><li><a href="#Hello-World">Hello World</a></li><li><a href="#Generic-Manipulation">Generic Manipulation</a></li><li><a href="#Coordinates">Coordinates</a></li><li><a href="#Positioning-and-Layout">Positioning and Layout</a></li><li><a href="#Drawing">Drawing</a></li></ul><li><a href="#Events">Events</a></li><ul><li><a href="#Wrapping">Wrapping</a></li><li><a href="#Bubbling">Bubbling</a></li><li><a href="#Reusable-by-Default">Reusable by Default</a></li><li><a href="#Events-in-the-Event-Loop">Events in the Event Loop</a></li></ul><li><a href="#Conclusion">Conclusion</a></li><li><a href="#Appendix">Appendix</a></li><ul><li><a href="#Platform-Agnostic">Platform Agnostic</a></li><li><a href="#Performance">Performance</a></li></ul><li><a href="#Footnotes">Footnotes</a></li></ul><p><em>This post is the second in a series of posts explaining the design principles behind <a href="https://github.com/phronmophobic/membrane">membrane</a>, a cross platform library for building fully functional user interfaces in clojure(script).</em></p><p>Next: <a href="reusable-ui-components.html">Reusable UI Components</a><br />Previous: <a href="what-is-a-user-interface.html">What is a User Interface?</a></p><p>Feedback is appreciated. Discuss on <a href="https://www.reddit.com/r/Clojure/comments/kb8mbp/implementing_a_functional_ui_model/">reddit</a> or file an issue on <a href="https://github.com/phronmophobic/membrane/issues/new">membrane&apos;s</a> github repo.</p><h1 id="Introduction">Introduction</h1><p><a href="what-is-a-user-interface.html">Previously</a>, on <strong>How to build a functional UI library from scratch</strong>. We defined a fully functional user interface as the combination of two pure functions, the event function and the view function. Next, we&apos;ll take a closer look at views, events, and how they are implemented in membrane.</p><p>In this post, we&apos;ll get into the nitty gritty of how the concepts outlined in the previous post are implemented. Many of the illustrative examples will be internal &quot;implementation details&quot; of membrane (which is a little bit like showing off your underwear). There are a few reasons for being a little risquÃ©:</p><ul><li><p>There are too many libraries building on top of React and not enough libraries working to fix the problems &quot;under&quot; React.</p></li><li><p>When working on membrane, it was difficult to find good references covering the designs of platform toolkits. Trawling through code bases like Chromium, GTK, QT, Swing, AWT, etc. for insights is arduous.</p></li><li><p>Building a library like membrane currently requires implementing a large surface area. Building user interfaces requires integrations with graphics libraries, platform toolkits, event handling, text rendering, and state management. There are high quality, functional options for state management, but most of these libraries are strongly coupled to a particular platform toolkit.<sup><a href="#footnote-1" name="footnote-ref-1" title=" I&apos;ve tried to extract some, but it&apos;s much more difficult than you might expect.">1</a></sup> Some design decisions in membrane were made thoughtfully and some design decisions were made to expedite the goal of having a fully working system where new ideas can be tested. Hopefully this post can provide some context for future library authors building &quot;underneath&quot; React.</p></li></ul><blockquote class="blockquote"><p>As we make things simpler, we get more independence of decisions because they&apos;re not interleaved<br /><footer class="blockquote-footer"><a href="https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/SimpleMadeEasy.md">Rich Hickey</a></footer></p></blockquote><p>One of the promises of building systems using simpler constructs is flexibility. Unfortunately, having more decision points can make the day to day development of software harder. To combat analysis paralysis, membrane follows &quot;make the common case easy and the complex case possible&quot;.<sup><a href="#footnote-2" name="footnote-ref-2" title="Derived from Larry Wall&apos;s &quot;make the easy things easy, and the hard things possible&quot;">2</a></sup> <sup><a href="#footnote-3" name="footnote-ref-3" title="Hopefully, this isn&apos;t too disappointing for the masochistic web developer that&apos;s used to &quot;make the common case complex, and the complex case janky&quot;.">3</a></sup> In practice, that means using simple constructs (make the complex case possible) and have tools, recipes, documentation and frameworks that package best practices for common tasks (make the common case easy). In this post, we&apos;ll be focusing on the simple constructs themselves, so it may not be clear how everything fits together until future posts. </p><h1 id="Event-loops">Event loops</h1><p>Thus far, everything has been a little fuzzy and abstract. For diving into actual code, an event loop is a great starting point. It&apos;s where the rubber hits the road. We get to <code>draw!</code>, <code>wait-events</code>, and other exciting side-effecty stuff ðŸ¤“ðŸ’¥ðŸ”¥! Below is the event loop used by membrane&apos;s <a href="https://github.com/phronmophobic/membrane/blob/master/src/membrane/skia.clj">skia backend</a>. The skia backend uses <a href="https://skia.org/">Skia</a> for graphics and <a href="https://www.glfw.org/">GLFW</a> for window management.</p><div class="syntax"><pre><span class="s-exp">(</span><span class="exception">try</span>
  <span class="s-exp">(</span><span class="conditional">when</span> <span class="s-exp">(</span><span class="symbol">init</span><span class="s-exp">)</span>
    <span class="s-exp">(</span><span class="symbol">add-windows!</span><span class="s-exp">)</span>

    <span class="s-exp">(</span><span class="special-form">loop</span> <span class="s-exp">[</span><span class="s-exp">]</span>
      <span class="s-exp">(</span><span class="symbol">wait-events</span><span class="s-exp">)</span>

      <span class="s-exp">(</span><span class="symbol">glGetError</span><span class="s-exp">)</span>

      <span class="s-exp">(</span><span class="symbol">add-windows!</span><span class="s-exp">)</span>

      <span class="s-exp">(</span><span class="symbol">close-windows!</span><span class="s-exp">)</span>

      <span class="s-exp">(</span><span class="symbol">run!</span> <span class="symbol">repaint!</span>
            <span class="s-exp">(</span><span class="core-fn">var-get</span> <span class="symbol">windows</span><span class="s-exp">)</span><span class="s-exp">)</span>

      <span class="s-exp">(</span><span class="conditional">when</span> <span class="s-exp">(</span><span class="core-fn">seq</span> <span class="s-exp">(</span><span class="core-fn">var-get</span> <span class="symbol">windows</span><span class="s-exp">)</span><span class="s-exp">)</span>
        <span class="s-exp">(</span><span class="special-form">recur</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
  <span class="s-exp">(</span><span class="exception">catch</span> <span class="symbol">Exception</span> <span class="symbol">e</span>
    <span class="s-exp">(</span><span class="core-fn">println</span> <span class="symbol">e</span><span class="s-exp">)</span><span class="s-exp">)</span>

  <span class="s-exp">(</span><span class="exception">finally</span>
    <span class="s-exp">(</span><span class="symbol">cleanup</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>The first observation might be that the event loop doesn&apos;t look very pure or functional (hint: it&apos;s not). The point of a functional architecture isn&apos;t to be side-effect free, but to have side effects at the edges and this is the edge.</p><p>The basic elements of this event loop are:</p><ul><li><p>initialize resources</p></li><li><p>waiting on events</p></li><li><p>redrawing</p></li><li><p>if there&apos;s more to do, loop</p></li><li><p>clean up</p></li></ul><p>Many event loops will follow a similar pattern. Most UI frameworks have <em>the</em> event loop which is hidden deep within the belly of the beast. As mentioned before, one of the promises of simplicity is flexibility. In membrane, when the platform toolkit allows, the decision of which event loop to use can be made independently of other architectural decisions. Most developers will use the good-enough default, but there will still be the option to use or create an alternative event loop should the use case demand it.</p><p>Some requirements for the event loop are imposed by operating systems and platforms. Some requirements are dictated by the application. For example, it may be useful to have a different event loop for development and testing purposes. Allowing event loops to be swapped out is an opportunity for frameworks to provide good options for specific use cases (eg. games, editors, document viewers, etc). For complex applications, it&apos;s common to use whatever hooks are available (eg. <code>setTimeout</code>, <code>requestAnimationFrame</code>) to try to suitably customize the event loop, but adding a bunch of hooks usually leads to an <a href="https://en.wikipedia.org/wiki/Inner-platform_effect">inner platform effect</a>.</p><p>Event loops are messy. The trick is to construct the event loop so that we can get back to using data and pure function as soon as possible.</p><h1 id="Graphics">Graphics</h1><p>As we try to get back to functional programming land, let&apos;s begin by taking a deeper look at the <code>repaint!</code> function referenced from our event loop:</p><div class="syntax"><pre><span class="s-exp">(</span><span class="symbol">repaint!</span> <span class="s-exp">[</span><span class="symbol">this</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="symbol">glfw-call</span> <span class="symbol">Void/TYPE</span> <span class="symbol">glfwMakeContextCurrent</span> <span class="symbol">window</span><span class="s-exp">)</span>

  <span class="s-exp">(</span><span class="symbol">Skia/skia_clear</span> <span class="symbol">skia-resource</span><span class="s-exp">)</span>

  <span class="s-exp">(</span><span class="macro">binding</span> <span class="s-exp">[</span><span class="symbol">*image-cache*</span> <span class="symbol">image-cache</span>
            <span class="symbol">*font-cache*</span> <span class="symbol">font-cache</span>
            <span class="symbol">*window*</span> <span class="symbol">this</span>
            <span class="symbol">*draw-cache*</span> <span class="symbol">draw-cache</span>
            <span class="symbol">*skia-resource*</span> <span class="symbol">skia-resource</span><span class="s-exp">]</span>
    <span class="s-exp">(</span><span class="special-form">let</span> <span class="s-exp">[</span><span class="symbol">view</span> <span class="s-exp">(</span><span class="core-fn">reset!</span> <span class="symbol">ui</span> <span class="s-exp">(</span><span class="symbol">view-fn</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">]</span>
      <span class="s-exp">(</span><span class="symbol">draw</span> <span class="symbol">view</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
  <span class="s-exp">(</span><span class="symbol">Skia/skia_flush</span> <span class="symbol">skia-resource</span><span class="s-exp">)</span>
  <span class="s-exp">(</span><span class="symbol">glfw-call</span> <span class="symbol">Void/TYPE</span> <span class="symbol">glfwSwapBuffers</span> <span class="symbol">window</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>All of this looks icky, but don&apos;t worry. We&apos;re almost ready to return to the safe haven of pure functions and data. The main reason to show these snippets is to demystify what&apos;s going on under the hood of UI frameworks<sup><a href="#footnote-4" name="footnote-ref-4" title="Is it working?">4</a></sup>. Most of the code is just boilerplate. Really, the main bit is this snippet:</p><div class="syntax"><pre><span class="s-exp">(</span><span class="special-form">let</span> <span class="s-exp">[</span><span class="symbol">view</span> <span class="s-exp">(</span><span class="core-fn">reset!</span> <span class="symbol">ui</span> <span class="s-exp">(</span><span class="symbol">view-fn</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="symbol">draw</span> <span class="symbol">view</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>Look! It&apos;s our friend, the view function! You may notice that <code>view-fn</code> doesn&apos;t receive any arguments. At this point, it&apos;s assumed that any state has been closed over. The event loop doesn&apos;t and shouldn&apos;t care about how state is handled. It only needs to know what to draw and who to tell about new input events.</p><p>All we needed to get back to data and pure functions was to separate <em>what to draw</em> from <em>how to draw it</em>.</p><h2 id="View-Function">View Function</h2><blockquote class="blockquote"><p><strong>View Function</strong> - a pure function which receives the relevant application state as an argument and returns data specifying <em>what</em> to draw (how to draw the data will be provided elsewhere). This facilitates communication from the application to the user.<br /><footer class="blockquote-footer"><a href="what-is-a-user-interface.html">What is a User Interface?</a></footer></p></blockquote><p>To get started, all we need is data that describes what to draw. We&apos;ll need a way to represent all the usual suspects:</p><ul><li><p>shapes with stroking and filling</p></li><li><p>images</p></li><li><p>text</p></li><li><p>grouping</p></li><li><p>2D transforms</p></li></ul><p>Membrane uses records. Below are some abbreviated definitions that membrane uses.<sup><a href="#footnote-5" name="footnote-ref-5" title=" The actual definitions are only slightly more verbose &lt;https://github.com/phronmophobic/membrane/blob/master/src/membrane/ui.cljc&gt;">5</a></sup></p><div class="syntax"><pre><span class="s-exp">(</span><span class="definition">defrecord</span> <span class="symbol">Label</span> <span class="s-exp">[</span><span class="symbol">text</span> <span class="symbol">font</span><span class="s-exp">]</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="definition">defrecord</span> <span class="symbol">Image</span> <span class="s-exp">[</span><span class="symbol">image-path</span> <span class="symbol">size</span> <span class="symbol">opacity</span><span class="s-exp">]</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="definition">defrecord</span> <span class="symbol">Rectangle</span> <span class="s-exp">[</span><span class="symbol">width</span> <span class="symbol">height</span><span class="s-exp">]</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="definition">defrecord</span> <span class="symbol">RoundedRectangle</span> <span class="s-exp">[</span><span class="symbol">width</span> <span class="symbol">height</span> <span class="symbol">border-radius</span><span class="s-exp">]</span><span class="s-exp">)</span>
</pre></div><h2 id="Grouping">Grouping</h2><p>Now that we have a few items we can draw, we need a way to compose them together. Clojure already has a data structure for grouping, vectors. A vector specifies a group of elements that should be drawn in order. Currently, sequences and maps have undefined meaning in our graphics model and are reserved for future specification. It&apos;s likely that sequences will have the same meaning as vectors.</p><p>It&apos;s still not clear what the optimal graphics data model is, but fortunately, it&apos;s pretty easy to beat <code>&lt;div/&gt;</code>s and <code>&lt;span/&gt;</code>s in terms of usability. Designing a better model is a promising area for improvement in the future. Clojure&apos;s data abstractions make it easy to provide an open model. If a newer, better model is available, it can be added without making breaking changes as long as the new model implements all of the relevant protocols.</p><h2 id="Transforms">Transforms</h2><p>Everyone&apos;s favorite 2D transforms:</p><div class="syntax"><pre><span class="s-exp">(</span><span class="definition">defrecord</span> <span class="symbol">Translate</span> <span class="s-exp">[</span><span class="symbol">x</span> <span class="symbol">y</span> <span class="symbol">drawable</span><span class="s-exp">]</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="definition">defrecord</span> <span class="symbol">Rotate</span> <span class="s-exp">[</span><span class="symbol">degrees</span> <span class="symbol">drawable</span><span class="s-exp">]</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="definition">defrecord</span> <span class="symbol">Skew</span> <span class="s-exp">[</span><span class="symbol">sx</span> <span class="symbol">sy</span> <span class="symbol">drawable</span><span class="s-exp">]</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="definition">defrecord</span> <span class="symbol">AffineTransform</span> <span class="s-exp">[</span><span class="symbol">matrix</span> <span class="symbol">drawable</span><span class="s-exp">]</span><span class="s-exp">)</span>
</pre></div><h2 id="Convenience-Wrappers">Convenience Wrappers</h2><p>Instantiating records directly is discouraged. Each record type has a wrapper function that should be used.</p><p>Examples:</p><div class="syntax"><pre><span class="s-exp">[</span><span class="s-exp">(</span><span class="symbol">ui/label</span> <span class="string">&quot;Hello World!&quot;</span><span class="s-exp">)</span>
 <span class="s-exp">(</span><span class="symbol">ui/translate</span> <span class="number">0</span> <span class="number">12</span>
               <span class="s-exp">[</span><span class="s-exp">(</span><span class="symbol">ui/label</span> <span class="string">&quot;Hello World!&quot;</span><span class="s-exp">)</span>
                <span class="s-exp">(</span><span class="symbol">ui/translate</span> <span class="number">0</span> <span class="number">12</span>
                              <span class="s-exp">(</span><span class="symbol">ui/label</span> <span class="string">&quot;Hello World!&quot;</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">]</span>
</pre></div><p>For more details about the graphics model, check out the <a href="https://github.com/phronmophobic/membrane/blob/master/docs/tutorial.md#graphics">graphics tutorial</a>.</p><h2 id="Hello-World">Hello World</h2><p>Now that we have a way to describe what to draw, we can now write the Hello World program with membrane. There are several options available in membrane for running a user interface. To &quot;run&quot; a user interface, you need some way to hook into the graphics and events provided by a platform toolkit. The platform toolkit hooks are called <strong>graphics backends</strong> in membrane. A graphics backend typically exposes a <code>run</code> function:</p><div class="syntax"><pre><span class="s-exp">(</span><span class="symbol">run</span> <span class="symbol">view-fn</span><span class="s-exp">)</span>
<span class="comment">;; and/or
</span><span class="s-exp">(</span><span class="symbol">run</span> <span class="symbol">view-fn</span> <span class="symbol">opts</span><span class="s-exp">)</span>
</pre></div><p>Here&apos;s the hello world code:</p><div class="syntax"><pre>
<span class="s-exp">(</span><span class="core-fn">require</span> <span class="reader-char">&apos;</span><span class="s-exp">[</span><span class="symbol">membrane.ui</span> <span class="keyword">:as</span> <span class="symbol">ui</span><span class="s-exp">]</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="core-fn">require</span> <span class="reader-char">&apos;</span><span class="s-exp">[</span><span class="symbol">membrane.skia</span> <span class="keyword">:as</span> <span class="symbol">backend</span><span class="s-exp">]</span><span class="s-exp">)</span>
<span class="comment">;; other example backends
</span><span class="comment">;; (require &apos;[membrane.lanterna :as backend]) ;; terminal
</span><span class="comment">;; (require &apos;[membrane.java2d :as backend]) ;; Swing
</span><span class="comment">;; (require &apos;[membrane.vdom :as backend]) ;; Web divs
</span><span class="comment">;; (require &apos;[membrane.webgl :as backend]) ;; Web openGL
</span>


<span class="s-exp">(</span><span class="definition">defn</span> <span class="symbol">view-fn</span> <span class="s-exp">[</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="symbol">ui/label</span> <span class="string">&quot;Hello World&quot;</span><span class="s-exp">)</span><span class="s-exp">)</span>
 

<span class="s-exp">(</span><span class="symbol">backend/run</span> <span class="symbol">view-fn</span><span class="s-exp">)</span>
<span class="comment">;; for webgl or vdom
</span><span class="comment">;; (backend/run view-fn {:container (.getElementById js/document &quot;my-hello-world-container&quot;)})
</span>
</pre></div><p>Creating a new backend is beyond the scope of this post, but making a minimal graphics backend only requires:</p><ol><li><p>An event loop</p></li><li><p>A few draw implementations (like shapes, images, and text)</p></li><li><p>A way to hook up input events (like mouse clicks, movement, and key presses, etc.)</p></li></ol><h2 id="Generic-Manipulation">Generic Manipulation</h2><p>The main idea is that graphical elements are values. They can be manipulated and inspected on any thread without synchronization. Views are semantically transparent which facilitates serialization, network transmission, storage, and implementation in multiple languages and platforms.</p><p>To support generic manipulation, membrane provides the following functions for inspecting any view:</p><div class="syntax"><pre><span class="comment">;; Specifies the top left corner of a component&apos;s bounds
</span><span class="comment">;; The origin is vector or 2 numbers [x, y]
</span><span class="s-exp">(</span><span class="symbol">origin</span> <span class="symbol">elem</span><span class="s-exp">)</span> <span class="comment">;; [5 10]
</span>
<span class="comment">;; Returns a 2 element vector with the [width, height] 
</span><span class="comment">;; of an element&apos;s bounds with respect to its origin
</span><span class="s-exp">(</span><span class="symbol">bounds</span> <span class="symbol">elem</span><span class="s-exp">)</span> <span class="comment">;; [50 100]
</span>
<span class="comment">;; Returns sub elements of elem. Useful for traversal.
</span><span class="s-exp">(</span><span class="symbol">children</span> <span class="symbol">elem</span><span class="s-exp">)</span> 

</pre></div><p>These functions are only the most basic tools for inspecting views. Just like clojure&apos;s suite of functions for slicing and dicing data keeps growing, so too will membrane&apos;s suite of functions for inspecting and manipulating views. Since views are just plain ol&apos; data, you get all the benefits of working with values.</p><h2 id="Coordinates">Coordinates</h2><p><img alt="Coordinates" src="ui-model/coordinates.png" style="max-width: 90vw;height:auto" /></p><p>Coordinates are represented as a vector of two numbers <code>[x, y]</code>.</p><h2 id="Positioning-and-Layout">Positioning and Layout</h2><p>Views are just data. When, where, and how to layout views can be decided independently.</p><p>Do you want to...</p><ul><li><p>use an <a href="https://constraints.cs.washington.edu/cassowary/">incremental constraint solver</a> like iOS?</p></li><li><p>precompute a bunch of layout data at compile time?</p></li><li><p>run your layout computations on a 128 core super computer and use STM (ie. refs) to build a consistent snapshot to present?</p></li><li><p>use flexbox?</p></li><li><p>arbitrarily split up your layout logic across 3 different languages?<sup><a href="#footnote-6" name="footnote-ref-6" title="(â•¯Â°â–¡Â°ï¼‰â•¯ï¸µ â”»â”â”»">6</a></sup></p></li></ul><p>Currently, membrane only provides basic layout functions, but since views are just data, it&apos;s straightforward to make more. For example, below is the implementation of <code>membrane.ui/center</code> which will vertically <em>and</em> horizontally center a view<sup><a href="#footnote-7" name="footnote-ref-7" title="Take that, css!">7</a></sup>:</p><div class="syntax"><pre>
<span class="s-exp">(</span><span class="definition">defn</span> <span class="symbol">center</span> <span class="s-exp">[</span><span class="symbol">elem</span> <span class="s-exp">[</span><span class="symbol">width</span> <span class="symbol">height</span><span class="s-exp">]</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="special-form">let</span> <span class="s-exp">[</span><span class="s-exp">[</span><span class="symbol">ewidth</span> <span class="symbol">eheight</span><span class="s-exp">]</span> <span class="s-exp">(</span><span class="symbol">bounds</span> <span class="symbol">elem</span><span class="s-exp">)</span><span class="s-exp">]</span>
    <span class="s-exp">(</span><span class="symbol">translate</span> <span class="s-exp">(</span><span class="core-fn">int</span> <span class="s-exp">(</span><span class="core-fn">-</span> <span class="s-exp">(</span><span class="core-fn">/</span> <span class="symbol">width</span> <span class="number">2</span><span class="s-exp">)</span>
                       <span class="s-exp">(</span><span class="core-fn">/</span> <span class="symbol">ewidth</span> <span class="number">2</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
               <span class="s-exp">(</span><span class="core-fn">int</span> <span class="s-exp">(</span><span class="core-fn">-</span> <span class="s-exp">(</span><span class="core-fn">/</span> <span class="symbol">height</span> <span class="number">2</span><span class="s-exp">)</span>
                       <span class="s-exp">(</span><span class="core-fn">/</span> <span class="symbol">eheight</span> <span class="number">2</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
               <span class="symbol">elem</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>Example usage:</p><div class="syntax"><pre>
<span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">container</span> <span class="s-exp">(</span><span class="symbol">ui/rectangle</span> <span class="number">100</span> <span class="number">100</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">centered-text</span> <span class="s-exp">(</span><span class="symbol">ui/center</span> <span class="s-exp">(</span><span class="symbol">ui/label</span> <span class="string">&quot;Hello&quot;</span><span class="s-exp">)</span>
                              <span class="s-exp">(</span><span class="symbol">ui/bounds</span> <span class="symbol">container</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
<span class="comment">;; #Translate{:x 33, :y 43,
</span><span class="comment">;;            :drawable #Label{:text &quot;Hello&quot;,
</span><span class="comment">;;                             :font #Font{:name nil,
</span><span class="comment">;;                                         :size 14,
</span><span class="comment">;;                                         :weight nil}}}
</span>
</pre></div><p>For more info, see <a href="https://github.com/phronmophobic/membrane/blob/master/docs/tutorial.md#basic-layout">Basic Layout</a>.</p><h2 id="Drawing">Drawing</h2><p>We won&apos;t say too much about how drawing is implemented. Most users won&apos;t be writing drawing code. One key idea is there is not one draw function, but many. The purpose of drawing is to turn a description of what to draw into pixels. There are dozens of ways to draw elements. Not only are there different algorithms and libraries, but also different targets (screens, image buffers, image files, etc.).</p><p>Many platform toolkits smush together what to draw with how to draw it. Separating <em>what</em> from <em>how</em> yields flexibility and reuse.</p><h1 id="Events">Events</h1><p>In membrane, the event model is pluggable. If the event model doesn&apos;t suit the use case, it can be swapped independently of other parts. Further, membrane&apos;s default event model isn&apos;t monolithic, so it&apos;s possible to reuse parts of the event model to construct a new event model if a small tweak is needed. Most applications will use the default event model &quot;as is&quot;, but the flexibility to replace or augment the event model for development, testing, performance, or tooling is a nice bonus. Creating an alternate event model is beyond the scope of this post. We&apos;ll simply refer to the default event model as the event model for the rest of this post.</p><p><strong>Event Function</strong> - a pure function which receives the application state and an event and returns data specifying the user&apos;s intent (eg. add a new todo item to the todo list). This facilitates communication from the user to the application.</p><p><strong>Event</strong>: Data representing the actions of a user. Examples of events are mouse clicks and key presses from a keyboard.</p><p><strong>Intent</strong>: Data representing a user intent. Examples of user intents are &quot;delete a todo list item&quot;, &quot;open a document&quot;, &quot;navigate to a URL&quot;.</p><p><strong>Effect</strong>: The carrying out of an intent.</p><p><strong>Event Handler</strong>: A pure function of an <strong>Event</strong> to <strong>Intents</strong>.</p><p>In practice, it&apos;s easier to specify the events and graphics together. Instead of having completely separate view and event functions, there&apos;s a single function that acts as both the view and event function. In other words, there&apos;s one function that returns data that describes what to draw and can translate events into intentions.</p><p>For each type of event, there is a corresponding protocol:</p><div class="syntax"><pre><span class="s-exp">(</span><span class="definition">defprotocol</span> <span class="symbol">IMouseMove</span> <span class="s-exp">(</span><span class="symbol">-mouse-move</span> <span class="s-exp">[</span><span class="symbol">elem</span> <span class="symbol">pos</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="definition">defprotocol</span> <span class="symbol">IMouseMoveGlobal</span> <span class="s-exp">(</span><span class="symbol">-mouse-move-global</span> <span class="s-exp">[</span><span class="symbol">elem</span> <span class="symbol">pos</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="definition">defprotocol</span> <span class="symbol">IMouseEvent</span> <span class="s-exp">(</span><span class="symbol">-mouse-event</span> <span class="s-exp">[</span><span class="symbol">elem</span> <span class="symbol">pos</span> <span class="symbol">button</span> <span class="symbol">mouse-down?</span> <span class="symbol">mods</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="definition">defprotocol</span> <span class="symbol">IDrop</span> <span class="s-exp">(</span><span class="symbol">-drop</span> <span class="s-exp">[</span><span class="symbol">elem</span> <span class="symbol">paths</span> <span class="symbol">pos</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="definition">defprotocol</span> <span class="symbol">IScroll</span> <span class="s-exp">(</span><span class="symbol">-scroll</span> <span class="s-exp">[</span><span class="symbol">elem</span> <span class="symbol">delta</span> <span class="symbol">mpos</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="definition">defprotocol</span> <span class="symbol">IMouseWheel</span> <span class="s-exp">(</span><span class="symbol">-mouse-wheel</span> <span class="s-exp">[</span><span class="symbol">elem</span> <span class="symbol">delta</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="definition">defprotocol</span> <span class="symbol">IKeyPress</span> <span class="s-exp">(</span><span class="symbol">-key-press</span> <span class="s-exp">[</span><span class="symbol">elem</span> <span class="core-fn">key</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="definition">defprotocol</span> <span class="symbol">IKeyType</span> <span class="s-exp">(</span><span class="symbol">-key-type</span> <span class="s-exp">[</span><span class="symbol">elem</span> <span class="core-fn">key</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="definition">defprotocol</span> <span class="symbol">IClipboardPaste</span> <span class="s-exp">(</span><span class="symbol">-clipboard-paste</span> <span class="s-exp">[</span><span class="symbol">elem</span> <span class="symbol">contents</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="definition">defprotocol</span> <span class="symbol">IClipboardCopy</span> <span class="s-exp">(</span><span class="symbol">-clipboard-copy</span> <span class="s-exp">[</span><span class="symbol">elem</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="definition">defprotocol</span> <span class="symbol">IClipboardCut</span> <span class="s-exp">(</span><span class="symbol">-clipboard-cut</span> <span class="s-exp">[</span><span class="symbol">elem</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>To specify an event handler, all that is needed is to implement the corresponding protocol. For convenience, the recommended way to add an event handler is by using <code>membrane.ui/on</code>.</p><div class="syntax"><pre><span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">my-elem</span> <span class="s-exp">(</span><span class="symbol">ui/on</span>
              <span class="keyword">:mouse-down</span> <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="s-exp">[</span><span class="symbol">mx</span> <span class="symbol">my</span><span class="s-exp">]</span><span class="s-exp">]</span>
                            <span class="s-exp">[</span><span class="s-exp">[</span><span class="keyword">::my-intent</span> <span class="symbol">mx</span> <span class="symbol">my</span><span class="s-exp">]</span><span class="s-exp">]</span><span class="s-exp">)</span>
              <span class="s-exp">(</span><span class="symbol">ui/label</span> <span class="string">&quot;hello world&quot;</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">mouse-pos</span> <span class="s-exp">[</span><span class="number">3</span> <span class="number">4</span><span class="s-exp">]</span><span class="s-exp">)</span>

<span class="comment">;; check to make sure it&apos;s working
</span><span class="s-exp">(</span><span class="symbol">ui/mouse-down</span> <span class="symbol">my-elem</span> <span class="symbol">mouse-pos</span><span class="s-exp">)</span> <span class="comment">;; [[::my-intent 3 4]]
</span></pre></div><p>Already, this example might look a little funny. What is <code>ui/mouse-down</code>? It&apos;s the event function! It really is just a pure function.</p><p>The other mystery is &quot;what&apos;s up with the handler&apos;s return value, <code>[[:my-intent mx my]]</code>?&quot;</p><p>In membrane&apos;s event model, event handlers should return a sequence of intents. An intent is a vector<sup><a href="#footnote-8" name="footnote-ref-8" title="Some frameworks have started to move away from using vectors for intents/effects towards using maps. Membrane may follow suit at some point.">8</a></sup> where the first element is the intent type. Using namespaced keywords for the intent type is encouraged.</p><p>It might not be apparent why having pure event functions is a big deal. For comparison, let&apos;s look at an event handler from <a href="http://day8.github.io/re-frame/dominoes-30k/#domino-1-event-dispatch">re-frame</a>:</p><pre><code>[:div.garbage-bin 
    :on-click #(re-frame.core/dispatch [:delete-item item-id])]
</code></pre><p>On the surface, this appears pretty similar, but architecturally, it&apos;s very different. The event handler has a side effect. Further, the dispatch function itself is hooked into global state. Essentially, we&apos;ve just tangled together parts of our application that should be decoupled. To be clear, this isn&apos;t <code>re-frame</code>&apos;s fault<sup><a href="#footnote-9" name="footnote-ref-9" title="`re-frame` is great. It&apos;s a really practical library and the community around it is helpful and friendly.">9</a></sup>. It&apos;s a limitation imposed by an OO event model addicted to side effects.</p><blockquote class="blockquote"><p>Computer science offers a standard way to handle complexity:hierarchical structure.<br /><footer class="blockquote-footer">Leslie Lamport <sup><a href="#footnote-10" name="footnote-ref-10" title="[How to Write a 21st Century Proof](https://lamport.azurewebsites.net/pubs/proof.pdf)">10</a></sup></footer></p></blockquote><p>As described in the previous post, the biggest issue with OO event systems is that they are primarily or exclusively side effect driven. Side effects ruin composition. In membrane, event handlers are pure functions that take the event data as arguments and return the intents of the user. In this regard, event handlers are more akin to ring&apos;s middleware or re-frame&apos;s interceptors.</p><p>In membrane, event handlers are composed hierarchically. Parent components may pass events down to child components and may alter or ignore the intents child components return. A key principle in membrane is that the parent is in charge. When event handlers contain side effects, this principle is violated. It means the parent component no longer has the final word on what intents will be returned from the event handler.</p><p>Let&apos;s take a look at how the mouse move event is implemented in membrane. A default implementation for all objects is provided.</p><div class="syntax"><pre><span class="s-exp">(</span><span class="macro">extend-type</span> <span class="reader-char">#</span><span class="symbol">?</span><span class="s-exp">(</span><span class="keyword">:clj</span> <span class="symbol">Object</span>
                <span class="keyword">:cljs</span> <span class="symbol">default</span><span class="s-exp">)</span>
  <span class="symbol">IMouseMove</span>
  <span class="s-exp">(</span><span class="symbol">-mouse-move</span> <span class="s-exp">[</span><span class="symbol">elem</span> <span class="symbol">local-pos</span><span class="s-exp">]</span>
    <span class="s-exp">(</span><span class="special-form">let</span> <span class="s-exp">[</span><span class="symbol">intents</span>
          <span class="s-exp">(</span><span class="core-fn">some</span> <span class="reader-char">#</span><span class="s-exp">(</span><span class="conditional">when-let</span> <span class="s-exp">[</span><span class="symbol">local-pos</span> <span class="s-exp">(</span><span class="symbol">within-bounds?</span> <span class="keyword">%</span> <span class="symbol">local-pos</span><span class="s-exp">)</span><span class="s-exp">]</span>
                   <span class="s-exp">(</span><span class="core-fn">seq</span> <span class="s-exp">(</span><span class="symbol">-mouse-move</span> <span class="keyword">%</span> <span class="symbol">local-pos</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
                <span class="s-exp">(</span><span class="core-fn">reverse</span> <span class="s-exp">(</span><span class="symbol">children</span> <span class="symbol">elem</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">]</span>
      <span class="s-exp">(</span><span class="symbol">-bubble</span> <span class="symbol">elem</span> <span class="symbol">intents</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>The default implementation simply delegates to the first (in reverse draw order) child component that is under the mouse and provides a response. Any element may provide its own mouse-move implementation, typically by using <code>membrane.ui/on</code> as demonstrated previously.</p><p>Since we&apos;re not ignoring the return value, we have some powerful functional tools for parent components to interact with the handlers of child components. The simplest example is simply ignoring all event handlers for a child component (aka. the functional equivalent of <code>.stopPropagation</code><sup><a href="#footnote-11" name="footnote-ref-11" title="Sorta">11</a></sup>).</p><div class="syntax"><pre><span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">my-elem</span> <span class="s-exp">(</span><span class="symbol">ui/on</span>
              <span class="keyword">:mouse-down</span> <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="s-exp">[</span><span class="symbol">mx</span> <span class="symbol">my</span><span class="s-exp">]</span><span class="s-exp">]</span>
                            <span class="s-exp">[</span><span class="s-exp">[</span><span class="keyword">::self-destruct</span><span class="s-exp">]</span><span class="s-exp">]</span><span class="s-exp">)</span>
              <span class="s-exp">(</span><span class="symbol">ui/label</span> <span class="string">&quot;Self Destruct&quot;</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">mouse-pos</span> <span class="s-exp">[</span><span class="number">3</span> <span class="number">4</span><span class="s-exp">]</span><span class="s-exp">)</span>

<span class="comment">;; uh oh
</span><span class="s-exp">(</span><span class="symbol">ui/mouse-down</span> <span class="symbol">my-elem</span> <span class="symbol">mouse-pos</span><span class="s-exp">)</span> <span class="comment">;; [[::self-destruct]]
</span>
<span class="comment">;; phew!
</span><span class="s-exp">(</span><span class="symbol">ui/mouse-down</span> <span class="s-exp">(</span><span class="symbol">ui/on</span> <span class="keyword">:mouse-down</span> <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">_</span><span class="s-exp">]</span> <span class="nil">nil</span><span class="s-exp">)</span>
                      <span class="symbol">my-elem</span><span class="s-exp">)</span>
               <span class="symbol">mouse-pos</span><span class="s-exp">)</span>
<span class="comment">;; =&gt; nil
</span></pre></div><p>In fact, it&apos;s possible to completely silence all event handlers for a child component by simply wrapping the component with <code>membrane.ui/no-events</code>.</p><div class="syntax"><pre><span class="s-exp">(</span><span class="symbol">membrane.ui/no-events</span> <span class="symbol">child-elem</span><span class="s-exp">)</span>
</pre></div><h3 id="Wrapping">Wrapping</h3><p>Wrapping child components is common and useful enough that it has its own function, <code>wrap-on</code> which will pass the child&apos;s event function as the first argument to the event handler.</p><p>Some examples of <code>wrap-on</code>:</p><div class="syntax"><pre><span class="comment">;; Add 10 to the x mouse position for all mouse-down
</span><span class="comment">;;  events processed by child components
</span><span class="s-exp">(</span><span class="symbol">ui/wrap-on</span>
 <span class="keyword">:mouse-down</span> <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">child-handler</span> <span class="s-exp">[</span><span class="symbol">mx</span> <span class="symbol">my</span><span class="s-exp">]</span><span class="s-exp">]</span>
               <span class="s-exp">(</span><span class="symbol">child-handler</span> <span class="s-exp">[</span><span class="s-exp">(</span><span class="core-fn">+</span> <span class="number">10</span> <span class="symbol">mx</span><span class="s-exp">)</span>
                               <span class="symbol">my</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">)</span>
 <span class="symbol">child-elem</span><span class="s-exp">)</span>

<span class="comment">;; remove all ::delete intents returned from the child view
</span><span class="s-exp">(</span><span class="symbol">ui/wrap-on</span>
 <span class="keyword">:mouse-down</span> <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">child-handler</span> <span class="s-exp">[</span><span class="symbol">mx</span> <span class="symbol">my</span><span class="s-exp">]</span><span class="s-exp">]</span>
               <span class="s-exp">(</span><span class="special-form">let</span> <span class="s-exp">[</span><span class="symbol">child-intents</span> <span class="s-exp">(</span><span class="symbol">child-handler</span> <span class="s-exp">[</span><span class="s-exp">(</span><span class="core-fn">+</span> <span class="number">10</span> <span class="symbol">mx</span><span class="s-exp">)</span>
                                                   <span class="symbol">my</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">]</span>
                 <span class="s-exp">(</span><span class="core-fn">remove</span> <span class="reader-char">#</span><span class="s-exp">(</span><span class="core-fn">=</span> <span class="keyword">::delete</span> <span class="s-exp">(</span><span class="core-fn">first</span> <span class="keyword">%</span><span class="s-exp">)</span><span class="s-exp">)</span> <span class="symbol">child-intents</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
 <span class="symbol">child-elem</span><span class="s-exp">)</span>

<span class="comment">;; Return all child intents and append some additional intents
</span><span class="s-exp">(</span><span class="symbol">ui/wrap-on</span>
 <span class="keyword">:mouse-down</span> <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">child-handler</span> <span class="s-exp">[</span><span class="symbol">mx</span> <span class="symbol">my</span><span class="s-exp">]</span><span class="s-exp">]</span>
               <span class="s-exp">(</span><span class="special-form">let</span> <span class="s-exp">[</span><span class="symbol">child-intents</span> <span class="s-exp">(</span><span class="symbol">child-handler</span> <span class="s-exp">[</span><span class="s-exp">(</span><span class="core-fn">+</span> <span class="number">10</span> <span class="symbol">mx</span><span class="s-exp">)</span>
                                                   <span class="symbol">my</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">]</span>
                 <span class="s-exp">(</span><span class="core-fn">into</span> <span class="symbol">child-intents</span>
                       <span class="s-exp">[</span><span class="s-exp">[</span><span class="keyword">::send-notification</span><span class="s-exp">]</span>
                        <span class="s-exp">[</span><span class="keyword">::cleanup</span><span class="s-exp">]</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
 <span class="symbol">child-elem</span><span class="s-exp">)</span>
</pre></div><h3 id="Bubbling">Bubbling</h3><p>If you were paying close attention to the default event handler implementation, you may have noticed the odd <code>(-bubble elem intents)</code> wrapping the return value.</p><p>The default implementation of <code>-bubble</code> is to simply return the intents unchanged:</p><div class="syntax"><pre><span class="s-exp">(</span><span class="symbol">-bubble</span> <span class="s-exp">[</span><span class="symbol">this</span> <span class="symbol">intents</span><span class="s-exp">]</span>
    <span class="symbol">intents</span><span class="s-exp">)</span>
</pre></div><p>The event function receives events and returns intents. Parent components may alter or ignore events before child components see the event and may alter or ignore intents before they are returned. Bubbling facilitates altering or ignoring the intents being returned by child components. In principle, modifying the outgoing intents could be achieved with <code>membrane.ui/wrap-on</code>, but that would require wrapping every event type<sup><a href="#footnote-12" name="footnote-ref-12" title="Bubbling may be implemented by wrapping all event types in the future. The main consideration is probably performance.">12</a></sup>.</p><p>Other event models also have &quot;bubbling&quot;, but membrane&apos;s bubbling is different. The return values of event handlers aren&apos;t ignored. Functional bubbling is powerful and provides an elegant way to make components more reusable with less code.</p><p>Functional bubbling allows you to alter intents that are getting passed back up the chain. Using <code>membrane.ui/on</code>, it&apos;s possible to listen for any intent type and transform it.</p><div class="syntax"><pre>
<span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">add-todo-button</span> <span class="s-exp">(</span><span class="symbol">ui/on</span> <span class="keyword">:mouse-down</span> <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">_</span><span class="s-exp">]</span>
                                          <span class="s-exp">[</span><span class="s-exp">[</span><span class="keyword">::add-todo</span><span class="s-exp">]</span><span class="s-exp">]</span><span class="s-exp">)</span>
                            <span class="s-exp">(</span><span class="symbol">ui/button</span> <span class="string">&quot;Add Todo&quot;</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="comment">;; wrap add-todo-button
</span><span class="comment">;; capture all ::add-todo intents bubbling and
</span><span class="comment">;; qualify that we&apos;re adding a todo to ::work-todos
</span><span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">work-add-todo-button</span> <span class="s-exp">(</span><span class="symbol">ui/on</span> <span class="keyword">::add-todo</span> <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="s-exp">]</span>
                                              <span class="s-exp">[</span><span class="s-exp">[</span><span class="keyword">::add-todo</span> <span class="keyword">::work-todos</span><span class="s-exp">]</span><span class="s-exp">]</span><span class="s-exp">)</span>
                                 <span class="symbol">add-todo-button</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">mpos</span> <span class="s-exp">[</span><span class="number">3</span> <span class="number">4</span><span class="s-exp">]</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="symbol">ui/mouse-down</span> <span class="symbol">add-todo-button</span>
               <span class="symbol">mpos</span><span class="s-exp">)</span> <span class="comment">;; [[::add-todo]]
</span>
<span class="s-exp">(</span><span class="symbol">ui/mouse-down</span> <span class="symbol">work-add-todo-button</span>
               <span class="symbol">mpos</span><span class="s-exp">)</span> <span class="comment">;; [[::add-todo ::work-todos]]
</span></pre></div><p>It may not be completely obvious why functional bubbling is important, but it&apos;s a critical technique for making components more reusable.</p><h2 id="Reusable-by-Default">Reusable by Default</h2><blockquote class="blockquote"><p>Often, several components need to reflect the same changing data.<br /><footer class="blockquote-footer">React docs: <a href="https://reactjs.org/docs/lifting-state-up.html">Lifting State Up</a></footer></p></blockquote><p>For a component to be reusable, it often needs to operate on nested state. Which subset of state can&apos;t be known ahead of time and multiple instances of a component may be operating on completely different state or on shared state. The recommended solution proposed by most libraries is to <em>rewrite</em> your component so you can <a href="https://reactjs.org/docs/lifting-state-up.html">lift state up</a>. Membrane contends that components should be reusable by default. Rather than rewriting components to delegate event handling, membrane advocates leveraging functional bubbling.</p><p>We&apos;ll use the the same temperature converter example from the react tutorial. The basic idea is to create a temperature converter widget. In membrane, that might look something like:</p><div class="syntax"><pre><span class="s-exp">(</span><span class="definition">defn</span> <span class="symbol">temperature-input</span> <span class="s-exp">[</span><span class="symbol">temperature</span> <span class="symbol">scale</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="symbol">ui/vertical-layout</span>
   <span class="s-exp">(</span><span class="symbol">ui/label</span> <span class="string">&quot;Enter temperature in &quot;</span> <span class="s-exp">(</span><span class="core-fn">get</span> <span class="symbol">scale-names</span> <span class="symbol">scale</span><span class="s-exp">)</span><span class="s-exp">)</span>
   <span class="s-exp">(</span><span class="symbol">textarea</span> <span class="keyword">:value</span> <span class="symbol">temperature</span>
             <span class="keyword">:on-change</span> <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="core-fn">val</span><span class="s-exp">]</span>
                          <span class="s-exp">[</span><span class="s-exp">[</span><span class="keyword">::change-temperature</span> <span class="s-exp">(</span><span class="symbol">parse-temp</span> <span class="core-fn">val</span><span class="s-exp">)</span><span class="s-exp">]</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>When the textarea changes, the event handler would return a <code>[::change-temperature parsed-temp-val]</code> intent. What happens if there is more than one temperature to change? Do we need to rewrite the temperature input? ... No! The temperature input doesn&apos;t need to know or care about which temperature it&apos;s operating on. We just need to adorn the returned intent with the necessary context using bubbling:</p><div class="syntax"><pre><span class="comment">;; Temperature calculator that shows multiple temperature inputs
</span><span class="comment">;; using the temperature-input component above
</span><span class="s-exp">(</span><span class="definition">defn</span> <span class="symbol">temperature-calculator</span> <span class="s-exp">[</span><span class="symbol">temps</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="core-fn">apply</span>
   <span class="symbol">ui/vertical-layout</span>
   <span class="s-exp">(</span><span class="macro">for</span> <span class="s-exp">[</span><span class="symbol">temp</span> <span class="symbol">temps</span><span class="s-exp">]</span>
     <span class="s-exp">(</span><span class="symbol">ui/on</span>
      <span class="keyword">::change-temperature</span>
      <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">new-temp</span><span class="s-exp">]</span>
        <span class="comment">;; adorn the intent with the temperature&apos;s id
</span>        <span class="s-exp">[</span><span class="s-exp">[</span><span class="keyword">::update-temperature</span> <span class="s-exp">(</span><span class="keyword">:id</span> <span class="symbol">temp</span><span class="s-exp">)</span> <span class="symbol">new-temp</span><span class="s-exp">]</span><span class="s-exp">]</span><span class="s-exp">)</span>
      <span class="s-exp">(</span><span class="symbol">temperature-input</span> <span class="s-exp">(</span><span class="keyword">:num</span> <span class="symbol">temp</span><span class="s-exp">)</span>
                         <span class="s-exp">(</span><span class="keyword">:scale</span> <span class="symbol">temp</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>We&apos;re skipping the state management part of this example for now, but we&apos;ll give it the full treatment in the next post!</p><h2 id="Events-in-the-Event-Loop">Events in the Event Loop</h2><p>Similar to how we were able to separate the control part of the event loop from the purely functional <code>view-fn</code>, we can separate the event functions from the control flow of the event loop. From our event loop, let&apos;s zoom in on the <code>wait-events</code> function:</p><div class="syntax"><pre><span class="s-exp">(</span><span class="definition">defn</span> <span class="symbol">wait-events</span> <span class="s-exp">[</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="symbol">glfw-call</span> <span class="symbol">void</span> <span class="symbol">glfwWaitEventsTimeout</span> <span class="s-exp">(</span><span class="core-fn">double</span> <span class="number">0.5</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>It&apos;s just a call to <code>glfwWaitEventsTimeout</code><sup><a href="#footnote-13" name="footnote-ref-13" title="Other options are `glfwWaitEvents`, `glfwPollEvents`, and `java.lang.Thread/sleep` which are sometimes used for debugging.">13</a></sup></p><blockquote class="blockquote"><p><strong>glfwWaitEventsTimeout</strong>: It puts the thread to sleep until at least one event has been received, or until the specified number of seconds have elapsed. It then processes any received events.<br /><footer class="blockquote-footer">GLFW <a href="https://www.glfw.org/docs/latest/input_guide.html">Input Guide</a></footer></p></blockquote><p>Processing events works by invoking callbacks that were set up during initialization(not shown in the above examples). Callbacks are then run in the event loop when <code>glfwWaitEventsTimeout</code> is called. Below is one of the callbacks. The other callbacks follow a similar pattern (some of the callbacks are a little messier because they need to standardize events to match other backends).</p><div class="syntax"><pre><span class="s-exp">(</span><span class="definition">defn-</span> <span class="symbol">-mouse-button-callback</span> <span class="s-exp">[</span><span class="symbol">window</span> <span class="symbol">window-handle</span> <span class="symbol">button</span> <span class="symbol">action</span> <span class="symbol">mods</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="exception">try</span>
    <span class="s-exp">(</span><span class="symbol">mouse-event</span> <span class="reader-char">@</span><span class="s-exp">(</span><span class="keyword">:ui</span> <span class="symbol">window</span><span class="s-exp">)</span>
                 <span class="reader-char">@</span><span class="s-exp">(</span><span class="keyword">:mouse-position</span> <span class="symbol">window</span><span class="s-exp">)</span>
                 <span class="symbol">button</span>
                 <span class="s-exp">(</span><span class="core-fn">=</span> <span class="number">1</span> <span class="symbol">action</span><span class="s-exp">)</span>
                 <span class="symbol">mods</span><span class="s-exp">)</span>
    <span class="s-exp">(</span><span class="exception">catch</span> <span class="symbol">Exception</span> <span class="symbol">e</span>
      <span class="s-exp">(</span><span class="core-fn">println</span> <span class="symbol">e</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>

  <span class="s-exp">(</span><span class="symbol">repaint!</span> <span class="symbol">window</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>Look! It&apos;s one of the event functions, <code>mouse-event</code>! Similar to the <code>view-fn</code>, <code>mouse-event</code> doesn&apos;t explicitly get passed state. At this point, it&apos;s assumed that any state has been closed over. The event loop doesn&apos;t and shouldn&apos;t care about how state is handled. It only needs to know what to draw and who to tell about new input events.</p><h1 id="Conclusion">Conclusion</h1><p>We&apos;ve now covered how membrane implements the Functional UI Model covered in the first post. Using the same (old) functional techniques, we&apos;ve replaced the common OO graphics and event models with functional ones. In the next post, we&apos;ll cover state management and show how to reap the benefits of working with data and pure functions.</p><p>Next: <a href="reusable-ui-components.html">Reusable UI Components</a><br />Previous: <a href="what-is-a-user-interface.html">What is a User Interface?</a></p><h1 id="Appendix">Appendix</h1><h2 id="Platform-Agnostic">Platform Agnostic</h2><p>The UI model provided by membrane is platform agnostic. It doesn&apos;t say anything that&apos;s specific to a particular operating system or environment. One accomplishment of the web is showing that user interfaces can be platform agnostic. Membrane doesn&apos;t argue that all interfaces <em>should</em> be platform agnostic, but UI libraries and frameworks shouldn&apos;t unnecessarily be coupled to particular platform toolkits or environments. There are times when leveraging platform specific features is the best or only option. Membrane&apos;s design is flexible enough to interoperate with platforms when necessary, but it also makes it easy to write platform independent user interfaces.</p><h2 id="Performance">Performance</h2><p>Performance is an important feature for any user interface. User interfaces that feel responsive are better. While many low hanging optimizations have been implemented, achieving the fastest benchmarks is not currently a priority. Membrane is still in the design phase and the highest priority is to optimize the design. Performance considerations will influence design decisions. While membrane is still in the design phase, bottlenecks will be addressed as necessary. If you experience a performance issue, please file a <a href="https://github.com/phronmophobic/membrane/issues/new">github issue</a>.</p><p>Having said that, one of the surprises of working on membrane is how responsive the resulting UIs feel. One of the main points of comparison is the web browser and it turns out the web browser spends a bunch of time monkeying around.</p><h1 id="Footnotes">Footnotes</h1><div class="footnotes"><div><a href="#footnote-ref-1" name="footnote-1">1</a>.  I&apos;ve tried to extract some, but it&apos;s much more difficult than you might expect.</div><div><a href="#footnote-ref-2" name="footnote-2">2</a>. Derived from Larry Wall&apos;s &quot;make the easy things easy, and the hard things possible&quot;</div><div><a href="#footnote-ref-3" name="footnote-3">3</a>. Hopefully, this isn&apos;t too disappointing for the masochistic web developer that&apos;s used to &quot;make the common case complex, and the complex case janky&quot;.</div><div><a href="#footnote-ref-4" name="footnote-4">4</a>. Is it working?</div><div><a href="#footnote-ref-5" name="footnote-5">5</a>.  The actual definitions are only slightly more verbose <a href="https://github.com/phronmophobic/membrane/blob/master/src/membrane/ui.cljc">https://github.com/phronmophobic/membrane/blob/master/src/membrane/ui.cljc</a></div><div><a href="#footnote-ref-6" name="footnote-6">6</a>. (â•¯Â°â–¡Â°ï¼‰â•¯ï¸µ â”»â”â”»</div><div><a href="#footnote-ref-7" name="footnote-7">7</a>. Take that, css!</div><div><a href="#footnote-ref-8" name="footnote-8">8</a>. Some frameworks have started to move away from using vectors for intents/effects towards using maps. Membrane may follow suit at some point.</div><div><a href="#footnote-ref-9" name="footnote-9">9</a>. <code>re-frame</code> is great. It&apos;s a really practical library and the community around it is helpful and friendly.</div><div><a href="#footnote-ref-10" name="footnote-10">10</a>. <a href="https://lamport.azurewebsites.net/pubs/proof.pdf">How to Write a 21st Century Proof</a></div><div><a href="#footnote-ref-11" name="footnote-11">11</a>. Sorta</div><div><a href="#footnote-ref-12" name="footnote-12">12</a>. Bubbling may be implemented by wrapping all event types in the future. The main consideration is probably performance.</div><div><a href="#footnote-ref-13" name="footnote-13">13</a>. Other options are <code>glfwWaitEvents</code>, <code>glfwPollEvents</code>, and <code>java.lang.Thread/sleep</code> which are sometimes used for debugging.</div></div></div></div></div></div></div></body></html>