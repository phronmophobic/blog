<html lang="en"><head><meta charset="utf-8" /><meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport" /><meta content="Adrian Smith" name="author" /><link href="ui-model/favicon.ico" rel="icon" /><title>Reusable UI Components</title><link href="ui-model/bootstrap.min.css" rel="stylesheet" /><link href="ui-model/blog.css" rel="stylesheet" /><style type="text/css">.syntax pre {
  background: ;
}

.syntax pre .definition {
  color: #00f;
}

.syntax pre .core-fn {
  color: #30a;
}

.syntax pre .variable {
  color: black;
}

.syntax pre .number {
  color: #164;
}

.syntax pre .s-exp {
  color: #997;
}

.syntax pre .special-form {
  color: #30a;
}

.syntax pre .string {
  color: #a11;
}

.syntax pre .keyword {
  color: #708;
}

.syntax pre .macro {
  color: #05a;
}

.syntax pre .reader-char {
  color: #555;
}

.syntax pre .nil {
  color: #164;
}

.syntax pre .comment {
  color: #a50;
}

.syntax pre .repeat {
  color: #f00;
}

.syntax pre .regex {
  color: #f50;
}

.syntax pre .exception {
  color: #f00;
}

.syntax pre .boolean {
  color: #164;
}

.syntax pre .character {
  color: #f50;
}

.syntax pre .conditional {
  color: #30a;
} div.syntax { padding: 4px ; background-color: #f8f8f8; margin-bottom: 18px } div.syntax pre { margin-bottom: 0 }</style></head><body><div class="blog-masthead"><div class="container"><nav class="nav blog-nav"><a class="nav-link" href="/">Home</a></nav></div></div><div class="blog-header"><div class="container"><h1 class="blog-title">Reusable UI Components</h1><p class="lead blog-description">How to build a functional UI library from scratch: Part III</p></div></div><div class="container"><div class="row"><div class="col-sm-8 blog-main"><div class="blog-post"><div><ul><li><a href="#Introduction">Introduction</a></li><li><a href="#The-Big-Idea">The Big Idea</a></li><li><a href="#What-Makes-a-Checkbox-Tick">What Makes a Checkbox Tick?</a></li><li><a href="#Effects">Effects</a></li><li><a href="#UI-State">UI State</a></li><ul><li><a href="#No-Updating-State">No Updating State</a></li><li><a href="#Implicit-State">Implicit State</a></li></ul><li><a href="#References">References</a></li><ul><li><a href="#Identifier">Identifier</a></li><li><a href="#Nesting">Nesting</a></li></ul><li><a href="#Membranes-Approach">Membrane&apos;s Approach</a></li><ul><li><a href="#Simple-State-with-References">Simple State with References</a></li><li><a href="#Syntax-for-references">Syntax for references</a></li><li><a href="#Why-is-defui-a-macro">Why is defui a macro?</a></li><li><a href="#Effect-Handling-revisited">Effect Handling revisited</a></li><ul><li><a href="#Processing-Effects-With-References">Processing Effects With References</a></li></ul><li><a href="#Incidental-State">Incidental State</a></li><ul><li><a href="#Public-API-vs-Private-API">Public API vs Private API</a></li><li><a href="#Contextual-State">Contextual State</a></li><li><a href="#Top-Level-State">Top Level State</a></li></ul></ul><li><a href="#What-is-a-UI-Component">What is a UI Component?</a></li><li><a href="#Reusability">Reusability</a></li><ul><li><a href="#Testing">Testing</a></li><li><a href="#Composing-Components">Composing Components</a></li></ul><li><a href="#To-Be-Continued">To Be Continued</a></li><li><a href="#Footnotes">Footnotes</a></li></ul><p><em>This post is the third  in a series of posts explaining the design principles behind <a href="https://github.com/phronmophobic/membrane">membrane</a>, a cross platform library for building fully functional user interfaces in clojure(script).</em></p><p>Previous posts: <a href="what-is-a-user-interface.html">What is a User Interface?</a>, <a href="ui-model.html">Implementing a Functional UI Model</a></p><p>Feedback is appreciated. Discuss on <a href="https://www.reddit.com/r/Clojure/comments/lq1os0/reusable_ui_components/">reddit</a> or <a href="https://github.com/phronmophobic/membrane/discussions">github</a>.</p><h1 id="Introduction">Introduction</h1><p>UI components in many frameworks couple state management and event handling. If we can untangle these two responsibilities, then we can make our components easier to test, reuse, debug, and reason about. Further, having simpler UI components will enable us to build improved tooling, which we&apos;ll cover in the next post.</p><p>Our strategy remains familiar. We&apos;ll try to build our UI components using only data and pure functions. We&apos;ve already shown in <a href="what-is-a-user-interface.html">Part I</a> and <a href="ui-model.html">Part II</a> that the view and event functions can be pure. The missing piece is a plan for implementing &quot;stateful&quot; components.</p><h1 id="The-Big-Idea">The Big Idea</h1><p>In this post, we&apos;ll:</p><ul><li><p>Define what we mean by &quot;UI component&quot;</p></li><li><p>Propose design constraints for building UI components and explain their reasoning</p></li></ul><p>The summary of the design constraints is:</p><ol><li><p>No side effects in view or event functions</p></li><li><p>Receive data only through function arguments</p><ul><li><p>corollary: No hidden/local state and don&apos;t use global state</p></li></ul></li><li><p>Use references (represented with immutable data) in event handlers to return intents that need to refer to input state or parts thereof.</p></li></ol><h1 id="What-Makes-a-Checkbox-Tick">What Makes a Checkbox Tick?</h1><p>Our dumb ice breaker question for today is &quot;What is a checkbox?&quot;. It&apos;s so obvious that it&apos;s difficult to put into words. Is a checkbox a fundamental UI block? Can it be broken down into smaller pieces? If so, what are the pieces that make up a checkbox?</p><h1 id="Effects">Effects</h1><p>Before we can talk about state, we need to talk about how effects like updating state are implemented. Let&apos;s refer back to some of the definitions from <a href="what-is-a-user-interface.html">part 1</a> of this series.</p><p><strong>Intent</strong>: Data representing a user intent. Examples of user intents are &quot;delete a todo list item&quot;, &quot;open a document&quot;, &quot;navigate to a URL&quot;.</p><p><strong>Event Function</strong>: a pure function which receives the application state and an event and returns data specifying the user&apos;s intent (eg. add a new todo item to the todo list).</p><p><strong>Effect</strong>: The carrying out of an intent.</p><p>Additionally, we&apos;ll add:</p><p><strong>Effect Handler</strong>: An impure function that receives <strong>intents</strong> and should process these intents by affecting the world.</p><p>As a refresher, membrane represents <strong>intents</strong> as a vector where the first value is the intent type, and the subsequent values are the arguments of the intent.</p><p>Below is a simple example of an effect handler that can process 2 types of intents:</p><ol><li><p><code>[:inc-counter]</code>: increment the current count</p></li><li><p><code>[:get-count]</code>: return the current count</p></li></ol><div class="syntax"><pre><span class="comment">;; handler for [:inc-counter]
</span><span class="s-exp">(</span><span class="definition">defn</span> <span class="symbol">inc-counter-effect</span> <span class="s-exp">[</span><span class="symbol">db</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="core-fn">swap!</span> <span class="symbol">db</span> <span class="core-fn">inc</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="comment">;; handler for [:get-count]
</span><span class="s-exp">(</span><span class="definition">defn</span> <span class="symbol">get-count-effect</span> <span class="s-exp">[</span><span class="symbol">db</span><span class="s-exp">]</span>
  <span class="reader-char">@</span><span class="symbol">db</span><span class="s-exp">)</span>

<span class="comment">;; helper function for creating the counter effect handler
</span><span class="s-exp">(</span><span class="definition">defn</span> <span class="symbol">make-counter-effect-handler</span> <span class="s-exp">[</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="special-form">let</span> <span class="s-exp">[</span><span class="symbol">db</span> <span class="s-exp">(</span><span class="core-fn">atom</span> <span class="number">0</span><span class="s-exp">)</span><span class="s-exp">]</span>
    <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">intent</span><span class="s-exp">]</span>
      <span class="s-exp">(</span><span class="special-form">let</span> <span class="s-exp">[</span><span class="symbol">intent-type</span> <span class="s-exp">(</span><span class="core-fn">first</span> <span class="symbol">intent</span><span class="s-exp">)</span><span class="s-exp">]</span>
        <span class="s-exp">(</span><span class="conditional">case</span> <span class="symbol">intent-type</span>
          <span class="keyword">:inc-counter</span> <span class="s-exp">(</span><span class="symbol">inc-counter-effect</span> <span class="symbol">db</span><span class="s-exp">)</span>
          <span class="keyword">:get-count</span> <span class="s-exp">(</span><span class="symbol">get-count-effect</span> <span class="symbol">db</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="comment">;; usage
</span><span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">my-counter-effect-handler</span> <span class="s-exp">(</span><span class="symbol">make-counter-effect-handler</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="symbol">my-counter-effect-handler</span> <span class="s-exp">[</span><span class="keyword">:get-count</span><span class="s-exp">]</span><span class="s-exp">)</span>
<span class="comment">;; 0
</span><span class="s-exp">(</span><span class="symbol">my-counter-effect-handler</span> <span class="s-exp">[</span><span class="keyword">:inc-counter</span><span class="s-exp">]</span><span class="s-exp">)</span>
<span class="comment">;; 1
</span><span class="s-exp">(</span><span class="symbol">my-counter-effect-handler</span> <span class="s-exp">[</span><span class="keyword">:get-count</span><span class="s-exp">]</span><span class="s-exp">)</span>
<span class="comment">;; 1
</span></pre></div><p>We&apos;ve implemented an example effect handler just to give a flavor of what an effect handler might look like. The example doesn&apos;t use any libraries or helper functions, but most applications will want to use a library to help create their effect handlers.</p><p>State management libraries should provide a means to specify an effect handler. For our examples, we&apos;ll use this snippet to &quot;install&quot; our effect handler:</p><div class="syntax"><pre><span class="s-exp">(</span><span class="definition">defn</span> <span class="symbol">with-effect-handler</span> <span class="s-exp">[</span><span class="symbol">handler</span> <span class="symbol">view</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="symbol">ui/on-bubble</span> <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">intents</span><span class="s-exp">]</span>
                  <span class="s-exp">(</span><span class="symbol">run!</span> <span class="symbol">handler</span> <span class="symbol">intents</span><span class="s-exp">)</span><span class="s-exp">)</span>
                <span class="symbol">view</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><h1 id="UI-State">UI State</h1><p>Now that we have a way to update state and execute side effects, we can move onto building &quot;stateful&quot; UI components. We&apos;ll still be using data and pure functions to build our UI components, but the code will generally look similar to UI components built with OO libraries and frameworks. However, we&apos;ll still have access to the benefits of functional code.</p><p>We&apos;ll start with the minimal case, no state, and slowly incorporate different kinds of state needed to build a feature rich user interface.</p><h2 id="No-Updating-State">No Updating State</h2><p>This is the easiest case. We already know how to accomplish this. A view with no updating state is just a pure function that receives data as its arguments and returns a view. Unfortunately, some frameworks still mess this up. Rather than having components receive data through function arguments, the data is injected via some other mechanism. We want to avoid injecting data through a side channel even when we do have stateful components, but it&apos;s especially egregious in the case where the state doesn&apos;t ever change.</p><h2 id="Implicit-State">Implicit State</h2><p>For our first example, let&apos;s examine a simple component which shows a &quot;More!&quot; button and a counter. Clicking the &quot;More!&quot; button will increment the counter.</p><p><img alt="Counter UI" src="ui-state/counter.gif" style="max-width: 90vw;height:auto" /></p><div class="syntax"><pre><span class="s-exp">(</span><span class="definition">defn</span> <span class="symbol">counter-ui</span> <span class="s-exp">[</span><span class="core-fn">num</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="symbol">ui/horizontal-layout</span>
   <span class="s-exp">(</span><span class="symbol">ui/on</span>
    <span class="keyword">:mouse-down</span> <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">_</span><span class="s-exp">]</span>
                  <span class="s-exp">[</span><span class="s-exp">[</span><span class="keyword">:inc-counter</span><span class="s-exp">]</span><span class="s-exp">]</span><span class="s-exp">)</span>
    <span class="s-exp">(</span><span class="symbol">ui/button</span> <span class="string">&quot;More!&quot;</span><span class="s-exp">)</span><span class="s-exp">)</span>
   <span class="s-exp">(</span><span class="symbol">ui/label</span> <span class="s-exp">(</span><span class="core-fn">str</span> <span class="string">&quot;current count: &quot;</span> <span class="core-fn">num</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>Notice that the mouse-down event handler returns the <code>[:inc-counter]</code> intent. We can test our <code>counter-ui</code> like so:</p><div class="syntax"><pre><span class="comment">;; check to make sure
</span><span class="comment">;; :inc-counter intent is returned when
</span><span class="comment">;; a mouse down event occurs within
</span><span class="comment">;; the More! button&apos;s bounds
</span><span class="s-exp">(</span><span class="symbol">ui/mouse-down</span> <span class="s-exp">(</span><span class="symbol">counter-ui</span> <span class="number">10</span><span class="s-exp">)</span>
               <span class="s-exp">[</span><span class="number">0</span> <span class="number">0</span><span class="s-exp">]</span><span class="s-exp">)</span>
<span class="comment">;; ([:inc-counter])
</span></pre></div><p>Now that we verified the intent is returned as expected, we can hook it up to an effect handler.</p><div class="syntax"><pre><span class="comment">;; Using the same effect handler in the Effects example
</span><span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">my-counter-effect-handler</span> <span class="s-exp">(</span><span class="symbol">make-counter-effect-handler</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="symbol">my-counter-effect-handler</span> <span class="s-exp">[</span><span class="keyword">:get-count</span><span class="s-exp">]</span><span class="s-exp">)</span>
<span class="comment">;; 0
</span>
<span class="comment">;; Execute the intents returned
</span><span class="comment">;; when clicking on the &quot;More!&quot; button
</span><span class="s-exp">(</span><span class="symbol">run!</span> <span class="symbol">my-counter-effect-handler</span>
      <span class="s-exp">(</span><span class="symbol">ui/mouse-down</span> <span class="s-exp">(</span><span class="symbol">counter-ui</span> <span class="number">10</span><span class="s-exp">)</span>
                     <span class="s-exp">[</span><span class="number">0</span> <span class="number">0</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="symbol">my-counter-effect-handler</span> <span class="s-exp">[</span><span class="keyword">:get-count</span><span class="s-exp">]</span><span class="s-exp">)</span>
<span class="comment">;; 1
</span></pre></div><p>Everything looks good. Now we can actually run the ui as a mini app.</p><div class="syntax"><pre><span class="comment">;; run the ui
</span><span class="s-exp">(</span><span class="symbol">backend/run</span>
  <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="s-exp">]</span>
    <span class="s-exp">(</span><span class="symbol">with-effect-handler</span> <span class="symbol">my-counter-effect-handler</span>
      <span class="s-exp">(</span><span class="symbol">counter-ui</span> <span class="s-exp">(</span><span class="symbol">my-counter-effect-handler</span> <span class="s-exp">[</span><span class="keyword">:get-count</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>Woohoo! We&apos;ve built our first stateful component. It&apos;s a small victory, but we&apos;ve still a long way to go.</p><p>When the &quot;More!&quot; button is clicked, it returns an <code>[:inc-counter]</code> intent, but the problem is that it doesn&apos;t say <em>which</em> counter should be incremented. What if there is more than one counter? How would we reuse <code>counter-ui</code> for controlling multiple counter instances?</p><p>The <code>counter-ui</code> is explicitly being passed the count, <code>num</code>, which is precisely the counter we would want to increment. To improve <code>counter-ui</code>, we should change the <code>[:inc-counter]</code> intent to specify <em>which</em> counter should be incremented. To specify which counter to increment, we need a way to represent a reference to the count passed to <code>counter-ui</code>.</p><h1 id="References">References</h1><blockquote class="blockquote"><p>By identity I mean a stable logical entity associated with a series of different values over time.<br /><footer class="blockquote-footer"><a href="https://clojure.org/about/state">https://clojure.org/about/state</a></footer></p></blockquote><p>Many, if not most, of the intents produced by a user interface will need to refer to entities. As an example, a todo list app will probably have intents like:</p><ul><li><p>Add a new todo to a todo list</p></li><li><p>Mark a todo as complete</p></li></ul><p>It&apos;s important for the corresponding intents to be able to say <em>which</em> todo list and <em>which</em> todo. The way we refer to entities is with <strong>references</strong>.</p><p><strong>Reference</strong>: Data that uniquely identifies an entity within a data model.</p><blockquote class="blockquote"><p>An entity can use three main techniques to refer to another entity: nesting, identifiers, and stateful references.<br /><footer class="blockquote-footer">Clojure Applied <sup><a href="#footnote-1" name="footnote-ref-1" title="Clojure Applied Chapter 1, top of page 14.">1</a></sup></footer></p></blockquote><p>What data constitutes a valid reference will depend on the data model. Designing a good data model plays a huge role in building an application that works well. Data modeling is a complex subject that is beyond the scope of this post. For our purposes, we&apos;ll assume an appropriate data model that uses either nesting or identifiers for referencing entities.</p><p>While membrane doesn&apos;t prevent using stateful references, it also offers no builtin support for the stateful reference approach. If you&apos;re curious about how a stateful reference approach might look, check out <a href="https://github.com/hoplon/hoplon">hoplon</a>, <a href="https://reagent-project.github.io/">reagent</a>, or the classic, STM based <a href="https://gist.github.com/michiakig/1093917">ant sim</a>.</p><p>Below are examples of intents with identifer and nesting based references. Even within a single data model, identifiers and nesting can be mixed and matched.</p><h2 id="Identifier">Identifier</h2><p>If the application has a data model where entities have unique identifiers, then simply using the entity&apos;s unique identifier as a reference will suffice. Using a todo app as an example and assuming that todo lists and todo items have unique <code>:id</code> keys, we can use the identifiers as references within intents.</p><p>Example:</p><div class="syntax"><pre><span class="comment">;; Intent for &quot;Add a new todo to a specific list&quot;
</span><span class="s-exp">[</span><span class="keyword">:add-todo</span> <span class="s-exp">(</span><span class="keyword">:id</span> <span class="symbol">todo-list</span><span class="s-exp">)</span> <span class="s-exp">{</span><span class="keyword">:done</span> <span class="boolean">false</span> <span class="keyword">:description</span> <span class="string">&quot;fix bugs&quot;</span><span class="s-exp">}</span><span class="s-exp">]</span>

<span class="comment">;; Intent for &quot;Mark todo as complete&quot;
</span><span class="s-exp">[</span><span class="keyword">:mark-todo-complete</span> <span class="s-exp">(</span><span class="keyword">:id</span> <span class="symbol">todo</span><span class="s-exp">)</span><span class="s-exp">]</span>
</pre></div><p>As long as the effect handler has a way to lookup and modify entities by id, then using identifiers as references is straightforward.</p><h2 id="Nesting">Nesting</h2><p>A nested data representation for a todo list app might look something like:</p><div class="syntax"><pre><span class="s-exp">{</span><span class="keyword">:todo-lists</span>
 <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:name</span> <span class="string">&quot;Work&quot;</span>
   <span class="keyword">:todos</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:done</span> <span class="boolean">false</span>
            <span class="keyword">:description</span> <span class="string">&quot;fix bugs&quot;</span><span class="s-exp">}</span>
           <span class="s-exp">{</span><span class="keyword">:done</span> <span class="boolean">false</span>
            <span class="keyword">:description</span> <span class="string">&quot;ship it&quot;</span><span class="s-exp">}</span><span class="s-exp">]</span><span class="s-exp">}</span>
  <span class="s-exp">{</span><span class="keyword">:name</span> <span class="string">&quot;Home&quot;</span>
   <span class="keyword">:todos</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:done</span> <span class="boolean">false</span>
            <span class="keyword">:description</span> <span class="string">&quot;fix bugs&quot;</span><span class="s-exp">}</span>
           <span class="s-exp">{</span><span class="keyword">:done</span> <span class="boolean">false</span>
            <span class="keyword">:description</span> <span class="string">&quot;ship it&quot;</span><span class="s-exp">}</span><span class="s-exp">]</span><span class="s-exp">}</span><span class="s-exp">]</span><span class="s-exp">}</span>
</pre></div><p>For this type of data model, the nested location of the entity can be used as a reference.<br />Example:</p><div class="syntax"><pre><span class="comment">;; Intent for &quot;Add a new todo to a specific list&quot;
</span><span class="s-exp">[</span><span class="keyword">:add-todo</span> <span class="reader-char">&apos;</span><span class="s-exp">[</span><span class="s-exp">(</span><span class="symbol">keypath</span> <span class="keyword">:todo-lists</span><span class="s-exp">)</span> <span class="s-exp">(</span><span class="core-fn">nth</span> <span class="number">0</span><span class="s-exp">)</span><span class="s-exp">]</span>
           <span class="s-exp">{</span><span class="keyword">:done</span> <span class="boolean">false</span> <span class="keyword">:description</span> <span class="string">&quot;fix bugs&quot;</span><span class="s-exp">}</span><span class="s-exp">]</span>

<span class="comment">;; Intent for &quot;Mark todo as complete&quot;
</span><span class="s-exp">[</span><span class="keyword">:mark-todo-complete</span> <span class="reader-char">&apos;</span><span class="s-exp">[</span><span class="s-exp">(</span><span class="symbol">keypath</span> <span class="keyword">:todo-lists</span><span class="s-exp">)</span>
                       <span class="s-exp">(</span><span class="core-fn">nth</span> <span class="number">1</span><span class="s-exp">)</span>
                       <span class="s-exp">(</span><span class="symbol">keypath</span> <span class="keyword">:todos</span><span class="s-exp">)</span>
                       <span class="s-exp">(</span><span class="core-fn">nth</span> <span class="number">0</span><span class="s-exp">)</span><span class="s-exp">]</span><span class="s-exp">]</span>
</pre></div><h1 id="Membranes-Approach">Membrane&apos;s Approach</h1><p>Up until this point, we&apos;ve only covered abstract concepts related to building stateful components. None of the ideas are unique to membrane and similar or analogous concepts will be found in most UI frameworks.</p><p>Below, we&apos;ll cover some of the tools membrane provides for state management. However, the key idea isn&apos;t that membrane&apos;s approach is the only or best solution. The main idea is that building user interfaces out of data and pure functions is worth it and we should be doing more of it. The only reason to cover membrane&apos;s approach is to show a working example. The design space for writing fully functional user interfaces is large and there&apos;s still plenty of unexplored territory!</p><h2 id="Simple-State-with-References">Simple State with References</h2><p>Now that we have a way to represent references, we can now return to our counter example and improve it.</p><p>The problem we ran into before diving into references was how to improve <code>[:inc-counter]</code> to reference the counter passed as an argument to <code>counter-ui</code>. We could use any of the reference types mentioned above, but it turns out our <code>counter-ui</code> component doesn&apos;t really care which type of identifier it uses.</p><p>In order to make it easy to build reusable components, membrane provides a macro for building UI components, <code>defui</code>.</p><p>Here&apos;s what <code>counter-ui</code> would look like if implemented with <code>defui</code>:</p><div class="syntax"><pre><span class="s-exp">(</span><span class="core-fn">require</span> <span class="reader-char">&apos;</span><span class="s-exp">[</span><span class="symbol">membrane.component</span> <span class="keyword">:refer</span> <span class="s-exp">[</span><span class="symbol">defui</span><span class="s-exp">]</span><span class="s-exp">]</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="symbol">defui</span> <span class="symbol">counter-ui</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:keys</span> <span class="s-exp">[</span><span class="core-fn">num</span><span class="s-exp">]</span><span class="s-exp">}</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="symbol">ui/horizontal-layout</span>
   <span class="s-exp">(</span><span class="symbol">ui/on</span>
    <span class="keyword">:mouse-down</span> <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">_</span><span class="s-exp">]</span>
                  <span class="s-exp">[</span><span class="s-exp">[</span><span class="keyword">:inc-counter</span> <span class="symbol">$num</span><span class="s-exp">]</span><span class="s-exp">]</span><span class="s-exp">)</span>
    <span class="s-exp">(</span><span class="symbol">ui/button</span> <span class="string">&quot;More!&quot;</span><span class="s-exp">)</span><span class="s-exp">)</span>
   <span class="s-exp">(</span><span class="symbol">ui/label</span> <span class="s-exp">(</span><span class="core-fn">str</span> <span class="string">&quot;current count: &quot;</span> <span class="core-fn">num</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>


<span class="comment">;; usage:
</span><span class="s-exp">(</span><span class="symbol">ui/mouse-down</span> <span class="s-exp">(</span><span class="symbol">counter-ui</span> <span class="s-exp">{</span><span class="keyword">:num</span> <span class="number">10</span><span class="s-exp">}</span><span class="s-exp">)</span>
               <span class="s-exp">[</span><span class="number">0</span> <span class="number">0</span><span class="s-exp">]</span><span class="s-exp">)</span>
<span class="comment">;; ([:inc-counter [(keypath :num)]])
</span>
</pre></div><p>There are 3 differences from our last iteration:</p><ol><li><p>The component is defined using <code>defui</code> instead of <code>defn</code></p></li><li><p>Rather than accepting the argument, <code>num</code>, it accepts a map with a <code>:num</code> key</p></li><li><p>The mouse down event now returns <code>[[:inc-counter $num]]</code> rather than <code>[[:inc-counter]]</code></p></li></ol><p>The first two differences are superficial. <code>counter-ui</code> is still just a pure function. The main features <code>defui</code> provides are:</p><ol><li><p>Providing syntax for references.</p></li><li><p>Automatically wiring incidental state (which we&apos;ll get to shortly).</p></li></ol><h2 id="Syntax-for-references">Syntax for references</h2><p>Within a <code>defui</code> definition, prefixing a symbol with <code>$</code> will replace that symbol with the reference for that symbol&apos;s value. For example, in our <code>counter-ui</code> definition above, <code>$num</code> will be replaced with a reference for <code>num</code>.</p><p>References only make sense for data that derives from arguments to the component. However, as long as data is derived from a component argument, then a valid reference can be produced. In the example below, even though <code>d</code> isn&apos;t directly passed as an argument, its reference can still be produced.</p><div class="syntax"><pre><span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">nested-data</span> <span class="s-exp">{</span><span class="keyword">:a</span> <span class="s-exp">{</span><span class="keyword">:b</span> <span class="s-exp">{</span><span class="keyword">:c</span> <span class="s-exp">{</span><span class="keyword">:d</span> <span class="number">1</span><span class="s-exp">}</span><span class="s-exp">}</span><span class="s-exp">}</span><span class="s-exp">}</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="symbol">defui</span> <span class="symbol">nested-view</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:keys</span> <span class="s-exp">[</span><span class="symbol">a</span><span class="s-exp">]</span><span class="s-exp">}</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="special-form">let</span> <span class="s-exp">[</span><span class="symbol">b</span> <span class="s-exp">(</span><span class="keyword">:b</span> <span class="symbol">a</span><span class="s-exp">)</span>
        <span class="symbol">c</span> <span class="s-exp">(</span><span class="keyword">:c</span> <span class="symbol">b</span><span class="s-exp">)</span>
        <span class="symbol">d</span> <span class="s-exp">(</span><span class="keyword">:d</span> <span class="symbol">c</span><span class="s-exp">)</span><span class="s-exp">]</span>
    <span class="s-exp">(</span><span class="symbol">ui/button</span> <span class="string">&quot;More!&quot;</span>
               <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="s-exp">]</span>
                 <span class="s-exp">[</span><span class="s-exp">[</span><span class="keyword">:inc-counter</span> <span class="symbol">$d</span><span class="s-exp">]</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>


<span class="s-exp">(</span><span class="symbol">ui/mouse-down</span> <span class="s-exp">(</span><span class="symbol">nested-view</span> <span class="symbol">nested-data</span><span class="s-exp">)</span>
               <span class="s-exp">[</span><span class="number">0</span> <span class="number">0</span><span class="s-exp">]</span><span class="s-exp">)</span>
<span class="comment">;; ([:inc-counter [(keypath :a)
</span><span class="comment">;;                 (keypath :b)
</span><span class="comment">;;                 (keypath :c)
</span><span class="comment">;;                 (keypath :d)]])
</span></pre></div><p>Currently, <code>defui</code> translates references to nested references, but the same syntax could be used with a data model that wants identifiers or stateful references. One benefit of using using nested references is that they can be automatically translated to identifiers if a schema is provided.</p><p>We can now extract the button as its own reusable component.</p><div class="syntax"><pre><span class="s-exp">(</span><span class="symbol">defui</span> <span class="symbol">more-button</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:keys</span> <span class="s-exp">[</span><span class="core-fn">num</span><span class="s-exp">]</span><span class="s-exp">}</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="symbol">ui/button</span> <span class="string">&quot;More!&quot;</span>
             <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="s-exp">]</span>
               <span class="s-exp">[</span><span class="s-exp">[</span><span class="keyword">:inc-counter</span> <span class="symbol">$num</span><span class="s-exp">]</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>

</pre></div><p>Next, rewrite <code>nested-view</code> using the extracted <code>more-button</code>.</p><div class="syntax"><pre><span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">nested-data</span> <span class="s-exp">{</span><span class="keyword">:a</span> <span class="s-exp">{</span><span class="keyword">:b</span> <span class="s-exp">{</span><span class="keyword">:c</span> <span class="s-exp">{</span><span class="keyword">:d</span> <span class="number">1</span><span class="s-exp">}</span><span class="s-exp">}</span><span class="s-exp">}</span><span class="s-exp">}</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="symbol">defui</span> <span class="symbol">nested-view</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:keys</span> <span class="s-exp">[</span><span class="symbol">a</span><span class="s-exp">]</span><span class="s-exp">}</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="special-form">let</span> <span class="s-exp">[</span><span class="symbol">b</span> <span class="s-exp">(</span><span class="keyword">:b</span> <span class="symbol">a</span><span class="s-exp">)</span>
        <span class="symbol">c</span> <span class="s-exp">(</span><span class="keyword">:c</span> <span class="symbol">b</span><span class="s-exp">)</span>
        <span class="symbol">d</span> <span class="s-exp">(</span><span class="keyword">:d</span> <span class="symbol">c</span><span class="s-exp">)</span><span class="s-exp">]</span>
    <span class="s-exp">(</span><span class="symbol">more-button</span> <span class="s-exp">{</span><span class="keyword">:num</span> <span class="symbol">d</span><span class="s-exp">}</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="symbol">ui/mouse-down</span> <span class="s-exp">(</span><span class="symbol">nested-view</span> <span class="symbol">nested-data</span><span class="s-exp">)</span>
               <span class="s-exp">[</span><span class="number">0</span> <span class="number">0</span><span class="s-exp">]</span><span class="s-exp">)</span>
<span class="comment">;; ([:inc-counter [(keypath :a)
</span><span class="comment">;;                 (keypath :b)
</span><span class="comment">;;                 (keypath :c)
</span><span class="comment">;;                 (keypath :d)]])
</span></pre></div><p>Notice how we were easily able to extract <code>more-button</code> without changing the intents returned by <code>nested-view</code>. The component <code>more-button</code> doesn&apos;t care where or how its argument, <code>num</code>, is stored. As long as <code>more-button</code> is passed a number, it doesn&apos;t matter how it&apos;s nested.</p><div class="syntax"><pre><span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">other-nested-data</span> <span class="s-exp">{</span><span class="keyword">:foo</span> <span class="s-exp">{</span><span class="keyword">:bar</span> <span class="s-exp">{</span><span class="keyword">:baz</span> <span class="number">1</span><span class="s-exp">}</span><span class="s-exp">}</span><span class="s-exp">}</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="symbol">defui</span> <span class="symbol">other-nested-view</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:keys</span> <span class="s-exp">[</span><span class="symbol">foo</span><span class="s-exp">]</span><span class="s-exp">}</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="special-form">let</span> <span class="s-exp">[</span><span class="symbol">bar</span> <span class="s-exp">(</span><span class="keyword">:bar</span> <span class="symbol">foo</span><span class="s-exp">)</span>
        <span class="symbol">baz</span> <span class="s-exp">(</span><span class="keyword">:baz</span> <span class="symbol">bar</span><span class="s-exp">)</span><span class="s-exp">]</span>
    <span class="s-exp">(</span><span class="symbol">more-button</span> <span class="s-exp">{</span><span class="keyword">:num</span> <span class="symbol">baz</span><span class="s-exp">}</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="symbol">ui/mouse-down</span> <span class="s-exp">(</span><span class="symbol">other-nested-view</span> <span class="symbol">other-nested-data</span><span class="s-exp">)</span>
               <span class="s-exp">[</span><span class="number">0</span> <span class="number">0</span><span class="s-exp">]</span><span class="s-exp">)</span>
<span class="comment">;; ([:inc-counter [(keypath :foo)
</span><span class="comment">;;                 (keypath :bar)
</span><span class="comment">;;                 (keypath :baz)]])
</span></pre></div><h2 id="Why-is-defui-a-macro">Why is defui a macro?</h2><p>Macros that introduce syntax are viewed with skepticism and they should be. It&apos;s easy to get carried away with macros and actually make the system more complex.</p><p>One major drawback of macros is that they often limit composability. Functions can be passed around, partially applied, and invoked programmatically and macros can&apos;t. Fortunately, this drawback doesn&apos;t apply to <code>defui</code> since its only purpose is to define a component. The component itself is just a pure function. The extra syntax is just sugar to reduce boilerplate and it&apos;s straightforward to replace a <code>defui</code> definition with either more verbose code or simply generate the same result programmatically.</p><p>A user interface is inherently about communication between a user and a software application. Application data is passed to the UI to produce the view and the user manipulates input devices like the keyboard and mouse to interact with the application data. Being able to easily refer to the nested entities being displayed aligns naturally with the UI&apos;s goal of translating raw input events like clicks and key presses into user intents.</p><p>Below is the definition for a checkbox:</p><div class="syntax"><pre><span class="s-exp">(</span><span class="symbol">defui</span> <span class="symbol">checkbox</span>
  <span class="string">&quot;Checkbox component.&quot;</span>
  <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:keys</span> <span class="s-exp">[</span><span class="symbol">checked?</span><span class="s-exp">]</span><span class="s-exp">}</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="symbol">on</span>
   <span class="keyword">:mouse-down</span>
   <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">_</span><span class="s-exp">]</span>
     <span class="s-exp">[</span><span class="s-exp">[</span><span class="keyword">::toggle</span> <span class="symbol">$checked?</span><span class="s-exp">]</span><span class="s-exp">]</span><span class="s-exp">)</span>
   <span class="comment">;; ui/checkbox is just
</span>   <span class="comment">;; a view of a checkbox
</span>   <span class="comment">;; with no event handling
</span>   <span class="s-exp">(</span><span class="symbol">ui/checkbox</span> <span class="symbol">checked?</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>Being able to reference the <code>checked?</code> value being passed in allows the checkbox definition to succinctly state the intent of the user when the checkbox is clicked. The intent, <code>[::toggle $checked?]</code>, is the most direct representation of the user&apos;s intent to toggle the checkbox&apos;s value.</p><p>To automatically substitute references, the <code>defui</code> macro traces derived values back to the component&apos;s arguments. Clojure programs almost exclusively interact with data using abstractions like <code>nth</code>, <code>get</code>, and keyword lookup. The result is that tracing how data is extracted and passed down can be automated effectively. Manual tracing is error prone and creates unnecessary coupling between UI components and unrelated parts of an application&apos;s data model. An alternate approach to macros is using a proxy value to track derived values. The <a href="https://github.com/omcljs/om">Om</a> clojurescript library used the proxy approach. The disadvantages of the proxy approach are:</p><ul><li><p>differences between the proxy and the underlying object</p></li><li><p>primitive types like numbers, strings, and booleans, can&apos;t be proxied</p></li><li><p>violates referential transparency</p></li></ul><p>A macro based approach circumvents these issues. The macro&apos;s only job is to reduce boilerplate by tracing derived values and automatically producing references.</p><p>Now that our intents include references, we need our effect handlers to be able to work with those references.</p><h2 id="Effect-Handling-revisited">Effect Handling revisited</h2><blockquote class="blockquote"><p>Make the common case easy and the complex case possible.<br /><footer class="blockquote-footer">Adapted from a Larry Wall quote</footer></p></blockquote><p>A major trick in our fight against complexity is to build complex components from simpler pieces. We would like to be able to build reusable components like textboxes that we can take apart for testing, debugging, tooling, etc, but we would also like them to be easy to use.</p><p>To make it easier to write effect handlers, membrane provides <code>defeffect</code> which can be use like so:</p><div class="syntax"><pre><span class="comment">;; provide an implementation for
</span><span class="comment">;; the ::fire-missiles intent
</span><span class="s-exp">(</span><span class="symbol">defeffect</span> <span class="keyword">::fire-missiles!</span> <span class="s-exp">[</span><span class="symbol">missile</span> <span class="symbol">target</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="symbol">fire-missile!</span> <span class="symbol">missile</span> <span class="symbol">target</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>For the most part, it looks and behaves similar to a normal function definition. Below is what the macro expanded version looks like:</p><div class="syntax"><pre><span class="s-exp">(</span><span class="special-form">let</span> <span class="s-exp">[</span><span class="symbol">fvar</span> <span class="s-exp">(</span><span class="definition">defn</span> <span class="symbol">effect-fire-missiles!</span> <span class="s-exp">[</span><span class="symbol">dispatch!</span> <span class="symbol">missile</span> <span class="symbol">target</span><span class="s-exp">]</span>
             <span class="s-exp">(</span><span class="symbol">fire-missile!</span> <span class="symbol">missile</span> <span class="symbol">target</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="core-fn">swap!</span> <span class="symbol">membrane.component/effects</span>
         <span class="core-fn">assoc</span>
         <span class="keyword">:my.ns/fire-missiles!</span> <span class="symbol">effect-fire-missiles!</span><span class="s-exp">)</span>
  <span class="symbol">fvar</span><span class="s-exp">)</span>
</pre></div><p><code>defeffect</code> does two things:</p><ul><li><p>defines a function for the effect handler in the current namespace</p></li><li><p>registers the effect handler in the global effect registry</p></li></ul><p>Since the effect handler is registered globally, fully qualified keywords are highly encouraged. The name of the function defined in the current namespace will be the same as the name of the intent with &quot;effect-&quot; prefixed to the name. The main reason for the prefix is that the effect handler (eg. <code>effect-fire-missiles!</code>) may want to rely on a similarly named function (eg. <code>fire-missiles!</code>) in the same namespace. The effect handler function defined in the local namespace won&apos;t generally be used directly, but it should have its own name so it can be tested/debugged/etc independently of the rest of the UI.</p><p>The last difference between <code>defeffect</code> and <code>defn</code> is that an implicit argument, <code>dispatch!</code>, is prepended to its argument list. We want to allow effect handlers to define themselves in terms of other effect handlers, but we don&apos;t want to directly connect implementations of effect handlers. For example, in development we may want the effect handler for <code>::notify-user</code> to print to stdout. In production, dispatching a <code>::notify-user</code> effect may send an email or text message.</p><p>The default effect handler uses all of the globally defined effect handlers, but an alternate effect handler that augments, instruments, replaces, or removes effect handlers can easily be produced and provided as the effect handler for a user interface.</p><h3 id="Processing-Effects-With-References">Processing Effects With References</h3><p>In addition to all of the globally defined effect handlers, the default effect handler also provides these  handlers:</p><ul><li><p><code>[:get $ref]</code></p></li><li><p><code>[:set $ref val]</code></p></li><li><p><code>[:update $ref f &amp; args]</code></p></li><li><p><code>[:delete $ref]</code></p></li></ul><p>The <code>$ref</code>s are references. Effect handlers that need to modify state can use these builtin handlers to update state by reference. For example, below is the implementation for the <code>::toggle</code> effect used by our <code>checkbox</code> example:</p><div class="syntax"><pre><span class="s-exp">(</span><span class="symbol">defeffect</span> <span class="keyword">::toggle</span> <span class="s-exp">[</span><span class="symbol">$bool</span><span class="s-exp">]</span>
  <span class="comment">;; use the builtin :update effect handler
</span>  <span class="comment">;; to update the reference to $bool
</span>  <span class="s-exp">(</span><span class="symbol">dispatch!</span> <span class="keyword">:update</span> <span class="symbol">$bool</span> <span class="core-fn">not</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p><strong>Note</strong>: outside of <code>defui</code>, the <code>$</code> prefix has no special meaning. It&apos;s only a convention used in membrane code for bindings that represent references (like <code>m</code> for map, <code>coll</code> for collections, etc).</p><p>Frameworks that don&apos;t have good support for references require effect handlers to unpack nested data, make modifications, and then repack it again. Under the hood, membrane relies on <a href="https://github.com/redplanetlabs/specter">specter</a> to efficiently update nested state. In practice, that means effect handlers require less code. Code that is simply unpacking and reconstructing nested data can simply be omitted. Below is an example that is unpacking, modifying, and reconstructing a nested data structure. The example is using re-frame, but a similar example could be taken from a number of different frameworks <sup><a href="#footnote-2" name="footnote-ref-2" title="&lt;https://github.com/tastejs/todomvc/blob/gh-pages/examples/scalajs-react/src/main/scala/todomvc/TodoModel.scala#L46&gt;">2</a></sup> <sup><a href="#footnote-3" name="footnote-ref-3" title="&lt;https://github.com/tastejs/todomvc/blob/gh-pages/examples/typescript-react/js/todoModel.js#L32&gt;">3</a></sup> <sup><a href="#footnote-4" name="footnote-ref-4" title="&lt;https://github.com/tastejs/todomvc/blob/gh-pages/examples/react-alt/js/stores/todoStore.js#L53&gt;">4</a></sup> <sup><a href="#footnote-5" name="footnote-ref-5" title="&lt;https://github.com/tastejs/todomvc/blob/gh-pages/examples/react/js/todoModel.js#L54&gt;">5</a></sup> <sup><a href="#footnote-6" name="footnote-ref-6" title="&lt;https://github.com/tastejs/todomvc/blob/gh-pages/examples/mithril/js/controllers/todo.js#L47&gt;">6</a></sup> <sup><a href="#footnote-7" name="footnote-ref-7" title="&lt;https://github.com/tastejs/todomvc/blob/gh-pages/examples/vanillajs/js/view.js#L201&gt;">7</a></sup> <sup><a href="#footnote-8" name="footnote-ref-8" title="&lt;https://github.com/day8/re-frame/blob/master/examples/todomvc/src/todomvc/events.cljs#L189&gt;">8</a></sup>.</p><div class="syntax"><pre><span class="s-exp">(</span><span class="symbol">reg-event-db</span>
  <span class="keyword">:toggle-done</span>
  <span class="symbol">todo-interceptors</span>
  <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">todos</span> <span class="s-exp">[</span><span class="symbol">_</span> <span class="symbol">id</span><span class="s-exp">]</span><span class="s-exp">]</span>
    <span class="s-exp">(</span><span class="core-fn">update-in</span> <span class="symbol">todos</span> <span class="s-exp">[</span><span class="symbol">id</span> <span class="keyword">:done</span><span class="s-exp">]</span> <span class="core-fn">not</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>This example doesn&apos;t look so bad, but there&apos;s a huge cost. Not only is manually writing code to unpack and repack nested data a waste of time, but the <code>:toggle-done</code> handler unnecessarily couples the toggling operation with the nested location of the value. For a small application, it&apos;s not a big deal, but the cost grows quickly as the size of the app grows. The coupling between the operation and a particular nested location doesn&apos;t just affect reuse, but it also hinders testing UI components in isolation.</p><h2 id="Incidental-State">Incidental State</h2><p>Using pure functions is great and all, but we&apos;ve got a huge problem. We often want to use a subcomponent and the subcomponent may have some incidental state that we really don&apos;t care about. For example, when we use a textbox, we usually only care about the the text being edited and couldn&apos;t care less about the current state of the cursor or text selection. Usually. Sometimes we do care about the cursor position, but not the text selection or vice versa.</p><p>One common mistake made by UI frameworks is that the subcomponent author decides which state is incidental rather than the code using the subcomponent. A key observation is that whether or not subcomponent state is incidental or essential depends on the use case. The parent component should always be in charge of deciding which state is essential and which state is incidental. Essential state should be provided explicitly. Ideally, incidental state should be provided implicitly so that the parent component doesn&apos;t have to think about how to wire state that isn&apos;t directly related to the problem being solved.</p><h3 id="Public-API-vs-Private-API">Public API vs Private API</h3><p>If the parent component decides which state is essential and which state is incidental, how do you keep the parent component from mucking with implementation details in the subcomponent? Deciding which state is part of the public API and which state is part of the private API is a separate, but related question. Public/private API state vs essential/incidental state is often conflated, but they&apos;re not the same thing. State that&apos;s part of the private API for a component should be, by definition, incidental state. However, it&apos;s important to note that even if state is part of the private API, it&apos;s often useful when debugging/developing/testing for the parent component to be able to treat the private state as an opaque value. For example, a bug might only occur when private state has a certain value and if the private state is completely inaccessible, then have fun trying to write tests or debug the issue.<sup><a href="#footnote-9" name="footnote-ref-9" title="If you&apos;ve ever tried to work around an issue caused by Chrome Autofill, you know the depths of despair that private, hidden state can cause.">9</a></sup> The recommended way to handle private API state in a membrane component is to put all the private state in a single map under a key named <code>:private</code>.</p><div class="syntax"><pre><span class="comment">;; store private API state in private variable
</span><span class="s-exp">(</span><span class="symbol">defui</span> <span class="symbol">my-component</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:keys</span> <span class="s-exp">[</span><span class="symbol">a</span> <span class="symbol">b</span> <span class="symbol">private</span><span class="s-exp">]</span><span class="s-exp">}</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="special-form">let</span> <span class="s-exp">[</span><span class="symbol">private-num</span> <span class="s-exp">(</span><span class="keyword">:num</span> <span class="symbol">private</span><span class="s-exp">)</span>
        <span class="symbol">private-str</span> <span class="s-exp">(</span><span class="keyword">:str</span> <span class="symbol">private</span><span class="s-exp">)</span><span class="s-exp">]</span>
    <span class="symbol">...</span><span class="s-exp">)</span><span class="s-exp">)</span>

</pre></div><p>Ok, so now we know where to put private API state, but if there is no &quot;hidden&quot; state, then it seems like it would be a pain to plumb incidental state all the way to the component that needs it. It would certainly be a nightmare if using a textbox meant passing a bunch of extra state around for every parent component, grandparent component, and so forth. Fortunately, plumbing incidental state can be automated and is taken care of implicitly by <code>defui</code>.</p><p>When a component is defined using <code>defui</code>, its var is adorned with metadata that marks it as a membrane component. Calls to membrane components within the body of a membrane component definition will automatically provide any incidental state necessary for child components. Superficially, accessing incidental state with automatic plumbing looks and feels similar to using <code>this.state</code>/<code>.setState</code>/<code>useState</code> from React, but it&apos;s architecturally very different. Rather than state being shoved in hidden, inaccessible places, the incidental state is stored in a well defined part of the normal application state. Having access to all of the UI state simplifies testing, debugging, and tooling.</p><h3 id="Contextual-State">Contextual State</h3><p>The next category of state we&apos;ll cover is contextual state. The most prominent example of contextual state is focus which is mostly about deciding which component should be responding to keyboard events. Generally speaking, contextual state smells a lot like global state so it is used sparingly. Contextual state is handled exactly the same way as incidental state, except rather than every component having its own incidental state, every component shares the same context.</p><p>To declare a component property as contextual, simply add the <code>:membrane.component/contextual</code> key to the metadata for the property like so:</p><div class="syntax"><pre><span class="s-exp">(</span><span class="symbol">defui</span> <span class="symbol">my-component</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:keys</span> <span class="s-exp">[</span><span class="symbol">a</span>
                             <span class="symbol">b</span>
                             <span class="reader-char">^</span><span class="keyword">:membrane.component/contextual</span>
                             <span class="symbol">my-context</span><span class="s-exp">]</span><span class="s-exp">}</span><span class="s-exp">]</span>
  <span class="symbol">...</span><span class="s-exp">)</span>
</pre></div><p>As always, the parent is in charge and if they decide that the property shouldn&apos;t be automatically passed to a child component, they can simply explicitly provide the property&apos;s value. By explicitly passing the property, it will no longer be treated like incidental state and will work exactly like any other property that makes up the essential state of the subcomponent.</p><h3 id="Top-Level-State">Top Level State</h3><p>We&apos;ll use &quot;Top Level&quot; to refer to whatever the most global scope is for a user interface. For a desktop app, the top level will typically be a window. For the web, the top level will typically be a root DOM element. Some examples of contextual state are modals, context menus, pop ups, scroll state, dropdowns, and drag&amp;drop. There&apos;s not actually anything special about top level state. The way membrane handles top level state is by providing a component, <code>membrane.component/top-level-ui</code> that receives a child component (your user interface) and takes care of all the top level state.</p><p>For ease of use, best practice is to use <code>membrane.component/make-app</code> to wrap your user interface with a <code>top-level-ui</code> component and connect it to an effect handler. If alternate behavior is desired, the underlying pieces can be rearranged/remixed to achieve the desired outcome.</p><h1 id="What-is-a-UI-Component">What is a UI Component?</h1><p>&quot;Component&quot; is often one of those words that gets used when no better name comes to mind (like Object, Manager, Widget, Controller, etc). One of the goals of membrane is to improve the precision of the jargon around UI programming.</p><p>A user interface is the combination of the two pure functions:</p><ol><li><p><strong>Event Function</strong> - a pure function which receives the application state and an event and returns data specifying the user&apos;s intent (eg. add a new todo item to the todo list).</p></li><li><p><strong>View Function</strong> - a pure function which receives the relevant application state as an argument and returns data specifying <em>what</em> to draw (how to draw the data will be provided elsewhere).</p></li></ol><p>A UI <strong>component</strong> is just a user interface whose event function returns intents with references to parts of the state passed in.</p><p>Using this definition, we can now answer &quot;What is checkbox?&quot;. We should be able to break down any component into its arguments, view function, event function, and default behavior. The break down for a checkbox is as follows:</p><ul><li><p><strong>checkbox arguments</strong>: A true/false value.</p></li><li><p><strong>view function</strong>: Returns a view that can represent two states (true/false) that correspond to the argument passed in.</p></li><li><p><strong>event function</strong>: When clicked, returns an intent that toggles the value passed in.</p></li><li><p><strong>default behavior</strong>: The default behavior for toggling should be logical negation.</p></li></ul><p>In code:</p><div class="syntax"><pre><span class="s-exp">(</span><span class="symbol">defeffect</span> <span class="keyword">::toggle</span> <span class="s-exp">[</span><span class="symbol">$bool</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="symbol">dispatch!</span> <span class="keyword">:update</span> <span class="symbol">$bool</span> <span class="core-fn">not</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="symbol">defui</span> <span class="symbol">checkbox</span>
  <span class="string">&quot;Checkbox component.&quot;</span>
  <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:keys</span> <span class="s-exp">[</span><span class="symbol">checked?</span><span class="s-exp">]</span><span class="s-exp">}</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="symbol">on</span>
   <span class="keyword">:mouse-down</span>
   <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">_</span><span class="s-exp">]</span>
     <span class="s-exp">[</span><span class="s-exp">[</span><span class="keyword">::toggle</span> <span class="symbol">$checked?</span><span class="s-exp">]</span><span class="s-exp">]</span><span class="s-exp">)</span>
   <span class="s-exp">(</span><span class="symbol">ui/checkbox</span> <span class="symbol">checked?</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><h1 id="Reusability">Reusability</h1><p>We&apos;ve finally covered all the different topics needed to build users interfaces out of data and pure functions. Ultimately, the goal is to make UI code more flexible, more reusable, and easier to reason about. Briefly, we&apos;ll cover some examples that highlight our progress.</p><p>Below are several examples of how UI interfaces usually aren&apos;t reusable:</p><ul><li><p>Testing user interfaces is cumbersome, highly manual, and/or ineffective</p></li><li><p>Components from different frameworks don&apos;t compose</p></li><li><p>Often, components from the same framework don&apos;t compose</p></li><li><p>Unnecessary coupling between components and state management undermines tooling</p></li></ul><p>By using data and pure functions, we can recover each of these capabilities. By default, everything snaps together, but the individual pieces can be extracted.</p><h2 id="Testing">Testing</h2><p>Testing in UI code tends to be less common. It&apos;s difficult to break user interfaces down into testable pieces. The main area where functional frameworks have focused is effect handling, which is a challenging area for testing. An important part of effect handling that has found some success with testing is state management. However, its effectiveness is often limited by hidden state and coupling between operations and specific nested locations.</p><p>The main benefit of just using data and pure functions is that nothing special is required for testing. Testing UI code is just like testing code for any other domain.</p><p>A component can be broken into its view function and event function. Event functions are just functions that return intents (ie. data). Crucially, view functions are just functions that return views (ie. data). Based off our work in part I and part II, it&apos;s even possible to do generative and property based testing with view functions.</p><p>Some examples of property based tests that may be interesting for views:</p><ul><li><p>Does the view fit within some bounds for all possible inputs?</p></li><li><p>Does the view contain no overlapping text for all possible inputs?</p></li><li><p>Are interactive elements obscured, invisible, or too small?</p></li><li><p>Are there pairs of foreground/background elements that have low contrast?</p></li><li><p>and more!</p></li></ul><p>Arguments to the view and event functions are just data and can be described with <code>spec</code>. Given a spec for a component&apos;s arguments, it&apos;s trivial to procedurally generate views and event handlers. Given an event handler, it&apos;s trivial to programmatically generate events for the event function to generate intents. Given an effect handler, the generated events can then exercise the effect handler. Basically, programmatically testing and driving a UI is as simple as testing and driving any other program.</p><h2 id="Composing-Components">Composing Components</h2><p>Membrane components can also be used from other UI frameworks. All that is required is to write a function that wraps a component with whichever state management option you desire. The transformation is entirely mechanical. A converter for each of re-frame<sup><a href="#footnote-10" name="footnote-ref-10" title="&lt;https://github.com/phronmophobic/membrane-re-frame-example/blob/master/src/membrane_re_frame_example/term_view.clj#L20&gt;">10</a></sup>, fulcro<sup><a href="#footnote-11" name="footnote-ref-11" title="&lt;https://github.com/phronmophobic/membrane-fulcro/blob/main/src/com/phronemophobic/todo.clj#L26&gt;">11</a></sup>, and cljfx<sup><a href="#footnote-12" name="footnote-ref-12" title="&lt;https://github.com/phronmophobic/membrane/blob/master/src/membrane/cljfx.clj#L914&gt;">12</a></sup> is provided within membrane. For example, <code>membrane.re-frame/defrf</code> can transform any membrane component into a re-frame component. In theory, a converter could be written for any state management framework.</p><p>Every UI framework has its own library of components that are all incompatible with every other UI framework. This is a huge waste of effort. Developers should be able to choose the framework that best suits them, but still have access to components from other frameworks. Why shouldn&apos;t UI components be usable from other frameworks? We already know how to do this<sup><a href="#footnote-13" name="footnote-ref-13" title="&lt;https://day8.github.io/re-frame/reusable-components/#implications&gt;">13</a></sup>. If we build our programs with data and pure functions, we reap flexibility and reuse.</p><h1 id="To-Be-Continued">To Be Continued</h1><p>Next time on &quot;How to build a functional UI library from scratch&quot;, we&apos;ll discuss what simple UI components means for UI tooling. Stay tuned!</p><h1 id="Footnotes">Footnotes</h1><div class="footnotes"><div><a href="#footnote-ref-1" name="footnote-1">1</a>. Clojure Applied Chapter 1, top of page 14.</div><div><a href="#footnote-ref-2" name="footnote-2">2</a>. <a href="https://github.com/tastejs/todomvc/blob/gh-pages/examples/scalajs-react/src/main/scala/todomvc/TodoModel.scala#L46">https://github.com/tastejs/todomvc/blob/gh-pages/examples/scalajs-react/src/main/scala/todomvc/TodoModel.scala#L46</a></div><div><a href="#footnote-ref-3" name="footnote-3">3</a>. <a href="https://github.com/tastejs/todomvc/blob/gh-pages/examples/typescript-react/js/todoModel.js#L32">https://github.com/tastejs/todomvc/blob/gh-pages/examples/typescript-react/js/todoModel.js#L32</a></div><div><a href="#footnote-ref-4" name="footnote-4">4</a>. <a href="https://github.com/tastejs/todomvc/blob/gh-pages/examples/react-alt/js/stores/todoStore.js#L53">https://github.com/tastejs/todomvc/blob/gh-pages/examples/react-alt/js/stores/todoStore.js#L53</a></div><div><a href="#footnote-ref-5" name="footnote-5">5</a>. <a href="https://github.com/tastejs/todomvc/blob/gh-pages/examples/react/js/todoModel.js#L54">https://github.com/tastejs/todomvc/blob/gh-pages/examples/react/js/todoModel.js#L54</a></div><div><a href="#footnote-ref-6" name="footnote-6">6</a>. <a href="https://github.com/tastejs/todomvc/blob/gh-pages/examples/mithril/js/controllers/todo.js#L47">https://github.com/tastejs/todomvc/blob/gh-pages/examples/mithril/js/controllers/todo.js#L47</a></div><div><a href="#footnote-ref-7" name="footnote-7">7</a>. <a href="https://github.com/tastejs/todomvc/blob/gh-pages/examples/vanillajs/js/view.js#L201">https://github.com/tastejs/todomvc/blob/gh-pages/examples/vanillajs/js/view.js#L201</a></div><div><a href="#footnote-ref-8" name="footnote-8">8</a>. <a href="https://github.com/day8/re-frame/blob/master/examples/todomvc/src/todomvc/events.cljs#L189">https://github.com/day8/re-frame/blob/master/examples/todomvc/src/todomvc/events.cljs#L189</a></div><div><a href="#footnote-ref-9" name="footnote-9">9</a>. If you&apos;ve ever tried to work around an issue caused by Chrome Autofill, you know the depths of despair that private, hidden state can cause.</div><div><a href="#footnote-ref-10" name="footnote-10">10</a>. <a href="https://github.com/phronmophobic/membrane-re-frame-example/blob/master/src/membrane_re_frame_example/term_view.clj#L20">https://github.com/phronmophobic/membrane-re-frame-example/blob/master/src/membrane_re_frame_example/term_view.clj#L20</a></div><div><a href="#footnote-ref-11" name="footnote-11">11</a>. <a href="https://github.com/phronmophobic/membrane-fulcro/blob/main/src/com/phronemophobic/todo.clj#L26">https://github.com/phronmophobic/membrane-fulcro/blob/main/src/com/phronemophobic/todo.clj#L26</a></div><div><a href="#footnote-ref-12" name="footnote-12">12</a>. <a href="https://github.com/phronmophobic/membrane/blob/master/src/membrane/cljfx.clj#L914">https://github.com/phronmophobic/membrane/blob/master/src/membrane/cljfx.clj#L914</a></div><div><a href="#footnote-ref-13" name="footnote-13">13</a>. <a href="https://day8.github.io/re-frame/reusable-components/#implications">https://day8.github.io/re-frame/reusable-components/#implications</a></div></div></div></div></div></div></div></body></html>